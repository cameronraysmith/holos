// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f /home/jeff/workspace/holos-run/holos-infra/deploy/clusters/k2/components/prod-platform-monitoring/prod-platform-monitoring.gen.yaml

package v1alpha1

import "strings"

// PrometheusAgent defines a Prometheus agent deployment.
#PrometheusAgent: {
	// APIVersion defines the versioned schema of this representation
	// of an object. Servers should convert recognized schemas to the
	// latest internal value, and may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "monitoring.coreos.com/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents. Servers may infer this from the endpoint
	// the client submits requests to. Cannot be updated. In
	// CamelCase. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "PrometheusAgent"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Specification of the desired behavior of the Prometheus agent.
	// More info:
	// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	spec!: #PrometheusAgentSpec
}

// Specification of the desired behavior of the Prometheus agent.
// More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
#PrometheusAgentSpec: {
	// AdditionalArgs allows setting additional arguments for the
	// 'prometheus' container.
	// It is intended for e.g. activating hidden flags which are not
	// supported by the dedicated configuration options yet. The
	// arguments are passed as-is to the Prometheus container which
	// may cause issues if they are invalid or not supported by the
	// given Prometheus version.
	// In case of an argument conflict (e.g. an argument which is
	// already set by the operator itself) or when providing an
	// invalid argument, the reconciliation will fail and an error
	// will be logged.
	additionalArgs?: [...{
		// Name of the argument, e.g. "scrape.discovery-reload-interval".
		name: strings.MinRunes(1)

		// Argument value, e.g. 30s. Can be empty for name-only arguments
		// (e.g. --storage.tsdb.no-lockfile)
		value?: string
	}]

	// AdditionalScrapeConfigs allows specifying a key of a Secret
	// containing additional Prometheus scrape configurations. Scrape
	// configurations specified are appended to the configurations
	// generated by the Prometheus Operator. Job configurations
	// specified must have the form as specified in the official
	// Prometheus documentation:
	// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
	// As scrape configs are appended, the user is responsible to
	// make sure it is valid. Note that using this feature may expose
	// the possibility to break upgrades of Prometheus. It is advised
	// to review Prometheus release notes to ensure that no
	// incompatible scrape configs are going to break Prometheus
	// after the upgrade.
	additionalScrapeConfigs?: {
		// The key of the secret to select from. Must be a valid secret
		// key.
		key: string

		// Name of the referent. More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		// TODO: Add other useful fields. apiVersion, kind, uid?
		name?: string

		// Specify whether the Secret or its key must be defined
		optional?: bool
	}

	// Defines the Pods' affinity scheduling rules if specified.
	affinity?: {
		// Describes node affinity scheduling rules for the pod.
		nodeAffinity?: {
			// The scheduler will prefer to schedule pods to nodes that
			// satisfy the affinity expressions specified by this field, but
			// it may choose a node that violates one or more of the
			// expressions. The node that is most preferred is the one with
			// the greatest sum of weights, i.e. for each node that meets all
			// of the scheduling requirements (resource request,
			// requiredDuringScheduling affinity expressions, etc.), compute
			// a sum by iterating through the elements of this field and
			// adding "weight" to the sum if the node matches the
			// corresponding matchExpressions; the node(s) with the highest
			// sum are the most preferred.
			preferredDuringSchedulingIgnoredDuringExecution?: [...{
				// A node selector term, associated with the corresponding weight.
				preference: {
					// A list of node selector requirements by node's labels.
					matchExpressions?: [...{
						// The label key that the selector applies to.
						key: string

						// Represents a key's relationship to a set of values. Valid
						// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
						operator: string

						// An array of string values. If the operator is In or NotIn, the
						// values array must be non-empty. If the operator is Exists or
						// DoesNotExist, the values array must be empty. If the operator
						// is Gt or Lt, the values array must have a single element,
						// which will be interpreted as an integer. This array is
						// replaced during a strategic merge patch.
						values?: [...string]
					}]

					// A list of node selector requirements by node's fields.
					matchFields?: [...{
						// The label key that the selector applies to.
						key: string

						// Represents a key's relationship to a set of values. Valid
						// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
						operator: string

						// An array of string values. If the operator is In or NotIn, the
						// values array must be non-empty. If the operator is Exists or
						// DoesNotExist, the values array must be empty. If the operator
						// is Gt or Lt, the values array must have a single element,
						// which will be interpreted as an integer. This array is
						// replaced during a strategic merge patch.
						values?: [...string]
					}]
				}

				// Weight associated with matching the corresponding
				// nodeSelectorTerm, in the range 1-100.
				weight: int
			}]
			requiredDuringSchedulingIgnoredDuringExecution?: {
				// Required. A list of node selector terms. The terms are ORed.
				nodeSelectorTerms: [...{
					// A list of node selector requirements by node's labels.
					matchExpressions?: [...{
						// The label key that the selector applies to.
						key: string

						// Represents a key's relationship to a set of values. Valid
						// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
						operator: string

						// An array of string values. If the operator is In or NotIn, the
						// values array must be non-empty. If the operator is Exists or
						// DoesNotExist, the values array must be empty. If the operator
						// is Gt or Lt, the values array must have a single element,
						// which will be interpreted as an integer. This array is
						// replaced during a strategic merge patch.
						values?: [...string]
					}]

					// A list of node selector requirements by node's fields.
					matchFields?: [...{
						// The label key that the selector applies to.
						key: string

						// Represents a key's relationship to a set of values. Valid
						// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
						operator: string

						// An array of string values. If the operator is In or NotIn, the
						// values array must be non-empty. If the operator is Exists or
						// DoesNotExist, the values array must be empty. If the operator
						// is Gt or Lt, the values array must have a single element,
						// which will be interpreted as an integer. This array is
						// replaced during a strategic merge patch.
						values?: [...string]
					}]
				}]
			}
		}

		// Describes pod affinity scheduling rules (e.g. co-locate this
		// pod in the same node, zone, etc. as some other pod(s)).
		podAffinity?: {
			// The scheduler will prefer to schedule pods to nodes that
			// satisfy the affinity expressions specified by this field, but
			// it may choose a node that violates one or more of the
			// expressions. The node that is most preferred is the one with
			// the greatest sum of weights, i.e. for each node that meets all
			// of the scheduling requirements (resource request,
			// requiredDuringScheduling affinity expressions, etc.), compute
			// a sum by iterating through the elements of this field and
			// adding "weight" to the sum if the node has pods which matches
			// the corresponding podAffinityTerm; the node(s) with the
			// highest sum are the most preferred.
			preferredDuringSchedulingIgnoredDuringExecution?: [...{
				// Required. A pod affinity term, associated with the
				// corresponding weight.
				podAffinityTerm: {
					// A label query over a set of resources, in this case pods. If
					// it's null, this PodAffinityTerm matches with no Pods.
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// MatchLabelKeys is a set of pod label keys to select which pods
					// will be taken into consideration. The keys are used to lookup
					// values from the incoming pod labels, those key-value labels
					// are merged with `LabelSelector` as `key in (value)` to select
					// the group of existing pods which pods will be taken into
					// consideration for the incoming pod's pod (anti) affinity. Keys
					// that don't exist in the incoming pod labels will be ignored.
					// The default value is empty. The same key is forbidden to exist
					// in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys
					// cannot be set when LabelSelector isn't set. This is an alpha
					// field and requires enabling MatchLabelKeysInPodAffinity
					// feature gate.
					matchLabelKeys?: [...string]

					// MismatchLabelKeys is a set of pod label keys to select which
					// pods will be taken into consideration. The keys are used to
					// lookup values from the incoming pod labels, those key-value
					// labels are merged with `LabelSelector` as `key notin (value)`
					// to select the group of existing pods which pods will be taken
					// into consideration for the incoming pod's pod (anti) affinity.
					// Keys that don't exist in the incoming pod labels will be
					// ignored. The default value is empty. The same key is forbidden
					// to exist in both MismatchLabelKeys and LabelSelector. Also,
					// MismatchLabelKeys cannot be set when LabelSelector isn't set.
					// This is an alpha field and requires enabling
					// MatchLabelKeysInPodAffinity feature gate.
					mismatchLabelKeys?: [...string]

					// A label query over the set of namespaces that the term applies
					// to. The term is applied to the union of the namespaces
					// selected by this field and the ones listed in the namespaces
					// field. null selector and null or empty namespaces list means
					// "this pod's namespace". An empty selector ({}) matches all
					// namespaces.
					namespaceSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// namespaces specifies a static list of namespace names that the
					// term applies to. The term is applied to the union of the
					// namespaces listed in this field and the ones selected by
					// namespaceSelector. null or empty namespaces list and null
					// namespaceSelector means "this pod's namespace".
					namespaces?: [...string]

					// This pod should be co-located (affinity) or not co-located
					// (anti-affinity) with the pods matching the labelSelector in
					// the specified namespaces, where co-located is defined as
					// running on a node whose value of the label with key
					// topologyKey matches that of any node on which any of the
					// selected pods is running. Empty topologyKey is not allowed.
					topologyKey: string
				}

				// weight associated with matching the corresponding
				// podAffinityTerm, in the range 1-100.
				weight: int
			}]

			// If the affinity requirements specified by this field are not
			// met at scheduling time, the pod will not be scheduled onto the
			// node. If the affinity requirements specified by this field
			// cease to be met at some point during pod execution (e.g. due
			// to a pod label update), the system may or may not try to
			// eventually evict the pod from its node. When there are
			// multiple elements, the lists of nodes corresponding to each
			// podAffinityTerm are intersected, i.e. all terms must be
			// satisfied.
			requiredDuringSchedulingIgnoredDuringExecution?: [...{
				// A label query over a set of resources, in this case pods. If
				// it's null, this PodAffinityTerm matches with no Pods.
				labelSelector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// MatchLabelKeys is a set of pod label keys to select which pods
				// will be taken into consideration. The keys are used to lookup
				// values from the incoming pod labels, those key-value labels
				// are merged with `LabelSelector` as `key in (value)` to select
				// the group of existing pods which pods will be taken into
				// consideration for the incoming pod's pod (anti) affinity. Keys
				// that don't exist in the incoming pod labels will be ignored.
				// The default value is empty. The same key is forbidden to exist
				// in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys
				// cannot be set when LabelSelector isn't set. This is an alpha
				// field and requires enabling MatchLabelKeysInPodAffinity
				// feature gate.
				matchLabelKeys?: [...string]

				// MismatchLabelKeys is a set of pod label keys to select which
				// pods will be taken into consideration. The keys are used to
				// lookup values from the incoming pod labels, those key-value
				// labels are merged with `LabelSelector` as `key notin (value)`
				// to select the group of existing pods which pods will be taken
				// into consideration for the incoming pod's pod (anti) affinity.
				// Keys that don't exist in the incoming pod labels will be
				// ignored. The default value is empty. The same key is forbidden
				// to exist in both MismatchLabelKeys and LabelSelector. Also,
				// MismatchLabelKeys cannot be set when LabelSelector isn't set.
				// This is an alpha field and requires enabling
				// MatchLabelKeysInPodAffinity feature gate.
				mismatchLabelKeys?: [...string]

				// A label query over the set of namespaces that the term applies
				// to. The term is applied to the union of the namespaces
				// selected by this field and the ones listed in the namespaces
				// field. null selector and null or empty namespaces list means
				// "this pod's namespace". An empty selector ({}) matches all
				// namespaces.
				namespaceSelector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// namespaces specifies a static list of namespace names that the
				// term applies to. The term is applied to the union of the
				// namespaces listed in this field and the ones selected by
				// namespaceSelector. null or empty namespaces list and null
				// namespaceSelector means "this pod's namespace".
				namespaces?: [...string]

				// This pod should be co-located (affinity) or not co-located
				// (anti-affinity) with the pods matching the labelSelector in
				// the specified namespaces, where co-located is defined as
				// running on a node whose value of the label with key
				// topologyKey matches that of any node on which any of the
				// selected pods is running. Empty topologyKey is not allowed.
				topologyKey: string
			}]
		}

		// Describes pod anti-affinity scheduling rules (e.g. avoid
		// putting this pod in the same node, zone, etc. as some other
		// pod(s)).
		podAntiAffinity?: {
			// The scheduler will prefer to schedule pods to nodes that
			// satisfy the anti-affinity expressions specified by this field,
			// but it may choose a node that violates one or more of the
			// expressions. The node that is most preferred is the one with
			// the greatest sum of weights, i.e. for each node that meets all
			// of the scheduling requirements (resource request,
			// requiredDuringScheduling anti-affinity expressions, etc.),
			// compute a sum by iterating through the elements of this field
			// and adding "weight" to the sum if the node has pods which
			// matches the corresponding podAffinityTerm; the node(s) with
			// the highest sum are the most preferred.
			preferredDuringSchedulingIgnoredDuringExecution?: [...{
				// Required. A pod affinity term, associated with the
				// corresponding weight.
				podAffinityTerm: {
					// A label query over a set of resources, in this case pods. If
					// it's null, this PodAffinityTerm matches with no Pods.
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// MatchLabelKeys is a set of pod label keys to select which pods
					// will be taken into consideration. The keys are used to lookup
					// values from the incoming pod labels, those key-value labels
					// are merged with `LabelSelector` as `key in (value)` to select
					// the group of existing pods which pods will be taken into
					// consideration for the incoming pod's pod (anti) affinity. Keys
					// that don't exist in the incoming pod labels will be ignored.
					// The default value is empty. The same key is forbidden to exist
					// in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys
					// cannot be set when LabelSelector isn't set. This is an alpha
					// field and requires enabling MatchLabelKeysInPodAffinity
					// feature gate.
					matchLabelKeys?: [...string]

					// MismatchLabelKeys is a set of pod label keys to select which
					// pods will be taken into consideration. The keys are used to
					// lookup values from the incoming pod labels, those key-value
					// labels are merged with `LabelSelector` as `key notin (value)`
					// to select the group of existing pods which pods will be taken
					// into consideration for the incoming pod's pod (anti) affinity.
					// Keys that don't exist in the incoming pod labels will be
					// ignored. The default value is empty. The same key is forbidden
					// to exist in both MismatchLabelKeys and LabelSelector. Also,
					// MismatchLabelKeys cannot be set when LabelSelector isn't set.
					// This is an alpha field and requires enabling
					// MatchLabelKeysInPodAffinity feature gate.
					mismatchLabelKeys?: [...string]

					// A label query over the set of namespaces that the term applies
					// to. The term is applied to the union of the namespaces
					// selected by this field and the ones listed in the namespaces
					// field. null selector and null or empty namespaces list means
					// "this pod's namespace". An empty selector ({}) matches all
					// namespaces.
					namespaceSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// namespaces specifies a static list of namespace names that the
					// term applies to. The term is applied to the union of the
					// namespaces listed in this field and the ones selected by
					// namespaceSelector. null or empty namespaces list and null
					// namespaceSelector means "this pod's namespace".
					namespaces?: [...string]

					// This pod should be co-located (affinity) or not co-located
					// (anti-affinity) with the pods matching the labelSelector in
					// the specified namespaces, where co-located is defined as
					// running on a node whose value of the label with key
					// topologyKey matches that of any node on which any of the
					// selected pods is running. Empty topologyKey is not allowed.
					topologyKey: string
				}

				// weight associated with matching the corresponding
				// podAffinityTerm, in the range 1-100.
				weight: int
			}]

			// If the anti-affinity requirements specified by this field are
			// not met at scheduling time, the pod will not be scheduled onto
			// the node. If the anti-affinity requirements specified by this
			// field cease to be met at some point during pod execution (e.g.
			// due to a pod label update), the system may or may not try to
			// eventually evict the pod from its node. When there are
			// multiple elements, the lists of nodes corresponding to each
			// podAffinityTerm are intersected, i.e. all terms must be
			// satisfied.
			requiredDuringSchedulingIgnoredDuringExecution?: [...{
				// A label query over a set of resources, in this case pods. If
				// it's null, this PodAffinityTerm matches with no Pods.
				labelSelector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// MatchLabelKeys is a set of pod label keys to select which pods
				// will be taken into consideration. The keys are used to lookup
				// values from the incoming pod labels, those key-value labels
				// are merged with `LabelSelector` as `key in (value)` to select
				// the group of existing pods which pods will be taken into
				// consideration for the incoming pod's pod (anti) affinity. Keys
				// that don't exist in the incoming pod labels will be ignored.
				// The default value is empty. The same key is forbidden to exist
				// in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys
				// cannot be set when LabelSelector isn't set. This is an alpha
				// field and requires enabling MatchLabelKeysInPodAffinity
				// feature gate.
				matchLabelKeys?: [...string]

				// MismatchLabelKeys is a set of pod label keys to select which
				// pods will be taken into consideration. The keys are used to
				// lookup values from the incoming pod labels, those key-value
				// labels are merged with `LabelSelector` as `key notin (value)`
				// to select the group of existing pods which pods will be taken
				// into consideration for the incoming pod's pod (anti) affinity.
				// Keys that don't exist in the incoming pod labels will be
				// ignored. The default value is empty. The same key is forbidden
				// to exist in both MismatchLabelKeys and LabelSelector. Also,
				// MismatchLabelKeys cannot be set when LabelSelector isn't set.
				// This is an alpha field and requires enabling
				// MatchLabelKeysInPodAffinity feature gate.
				mismatchLabelKeys?: [...string]

				// A label query over the set of namespaces that the term applies
				// to. The term is applied to the union of the namespaces
				// selected by this field and the ones listed in the namespaces
				// field. null selector and null or empty namespaces list means
				// "this pod's namespace". An empty selector ({}) matches all
				// namespaces.
				namespaceSelector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// namespaces specifies a static list of namespace names that the
				// term applies to. The term is applied to the union of the
				// namespaces listed in this field and the ones selected by
				// namespaceSelector. null or empty namespaces list and null
				// namespaceSelector means "this pod's namespace".
				namespaces?: [...string]

				// This pod should be co-located (affinity) or not co-located
				// (anti-affinity) with the pods matching the labelSelector in
				// the specified namespaces, where co-located is defined as
				// running on a node whose value of the label with key
				// topologyKey matches that of any node on which any of the
				// selected pods is running. Empty topologyKey is not allowed.
				topologyKey: string
			}]
		}
	}

	// APIServerConfig allows specifying a host and auth methods to
	// access the Kuberntees API server. If null, Prometheus is
	// assumed to run inside of the cluster: it will discover the API
	// servers automatically and use the Pod's CA certificate and
	// bearer token file at
	// /var/run/secrets/kubernetes.io/serviceaccount/.
	apiserverConfig?: {
		// Authorization section for the API server.
		// Cannot be set at the same time as `basicAuth`, `bearerToken`,
		// or `bearerTokenFile`.
		authorization?: {
			// Selects a key of a Secret in the namespace that contains the
			// credentials for authentication.
			credentials?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// File to read a secret from, mutually exclusive with
			// `credentials`.
			credentialsFile?: string

			// Defines the authentication type. The value is case-insensitive.
			// "Basic" is not a supported value.
			// Default: "Bearer"
			type?: string
		}

		// BasicAuth configuration for the API server.
		// Cannot be set at the same time as `authorization`,
		// `bearerToken`, or `bearerTokenFile`.
		basicAuth?: {
			// `password` specifies a key of a Secret containing the password
			// for authentication.
			password?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// `username` specifies a key of a Secret containing the username
			// for authentication.
			username?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}
		}

		// *Warning: this field shouldn't be used because the token value
		// appears in clear-text. Prefer using `authorization`.*
		// Deprecated: this will be removed in a future release.
		bearerToken?: string

		// File to read bearer token for accessing apiserver.
		// Cannot be set at the same time as `basicAuth`, `authorization`,
		// or `bearerToken`.
		// Deprecated: this will be removed in a future release. Prefer
		// using `authorization`.
		bearerTokenFile?: string

		// Kubernetes API address consisting of a hostname or IP address
		// followed by an optional port number.
		host: string

		// TLS Config to use for the API server.
		tlsConfig?: {
			// Certificate authority used when verifying server certificates.
			ca?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the CA cert in the Prometheus container to use for the
			// targets.
			caFile?: string

			// Client certificate to present when doing client-authentication.
			cert?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the client cert file in the Prometheus container for
			// the targets.
			certFile?: string

			// Disable target certificate validation.
			insecureSkipVerify?: bool

			// Path to the client key file in the Prometheus container for the
			// targets.
			keyFile?: string

			// Secret containing the client key file for the targets.
			keySecret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Used to verify the hostname for the targets.
			serverName?: string
		}
	}
	arbitraryFSAccessThroughSMs?: {
		deny?: bool
	}

	// BodySizeLimit defines per-scrape on response body size. Only
	// valid in Prometheus versions 2.45.0 and newer.
	bodySizeLimit?: =~"(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"

	// ConfigMaps is a list of ConfigMaps in the same namespace as the
	// Prometheus object, which shall be mounted into the Prometheus
	// Pods. Each ConfigMap is added to the StatefulSet definition as
	// a volume named `configmap-<configmap-name>`. The ConfigMaps
	// are mounted into /etc/prometheus/configmaps/<configmap-name>
	// in the 'prometheus' container.
	configMaps?: [...string]

	// Containers allows injecting additional containers or modifying
	// operator generated containers. This can be used to allow
	// adding an authentication proxy to the Pods or to change the
	// behavior of an operator generated container. Containers
	// described here modify an operator generated container if they
	// share the same name and modifications are done via a strategic
	// merge patch.
	// The names of containers managed by the operator are: *
	// `prometheus` * `config-reloader` * `thanos-sidecar`
	// Overriding containers is entirely outside the scope of what the
	// maintainers will support and by doing so, you accept that this
	// behaviour may break at any time without notice.
	containers?: [...{
		// Arguments to the entrypoint. The container image's CMD is used
		// if this is not provided. Variable references $(VAR_NAME) are
		// expanded using the container's environment. If a variable
		// cannot be resolved, the reference in the input string will be
		// unchanged. Double $$ are reduced to a single $, which allows
		// for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
		// produce the string literal "$(VAR_NAME)". Escaped references
		// will never be expanded, regardless of whether the variable
		// exists or not. Cannot be updated. More info:
		// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
		args?: [...string]

		// Entrypoint array. Not executed within a shell. The container
		// image's ENTRYPOINT is used if this is not provided. Variable
		// references $(VAR_NAME) are expanded using the container's
		// environment. If a variable cannot be resolved, the reference
		// in the input string will be unchanged. Double $$ are reduced
		// to a single $, which allows for escaping the $(VAR_NAME)
		// syntax: i.e. "$$(VAR_NAME)" will produce the string literal
		// "$(VAR_NAME)". Escaped references will never be expanded,
		// regardless of whether the variable exists or not. Cannot be
		// updated. More info:
		// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
		command?: [...string]

		// List of environment variables to set in the container. Cannot
		// be updated.
		env?: [...{
			// Name of the environment variable. Must be a C_IDENTIFIER.
			name: string

			// Variable references $(VAR_NAME) are expanded using the
			// previously defined environment variables in the container and
			// any service environment variables. If a variable cannot be
			// resolved, the reference in the input string will be unchanged.
			// Double $$ are reduced to a single $, which allows for escaping
			// the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the
			// string literal "$(VAR_NAME)". Escaped references will never be
			// expanded, regardless of whether the variable exists or not.
			// Defaults to "".
			value?: string

			// Source for the environment variable's value. Cannot be used if
			// value is not empty.
			valueFrom?: {
				// Selects a key of a ConfigMap.
				configMapKeyRef?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Selects a field of the pod: supports metadata.name,
				// metadata.namespace, `metadata.labels['<KEY>']`,
				// `metadata.annotations['<KEY>']`, spec.nodeName,
				// spec.serviceAccountName, status.hostIP, status.podIP,
				// status.podIPs.
				fieldRef?: {
					// Version of the schema the FieldPath is written in terms of,
					// defaults to "v1".
					apiVersion?: string

					// Path of the field to select in the specified API version.
					fieldPath: string
				}

				// Selects a resource of the container: only resources limits and
				// requests (limits.cpu, limits.memory, limits.ephemeral-storage,
				// requests.cpu, requests.memory and requests.ephemeral-storage)
				// are currently supported.
				resourceFieldRef?: {
					// Container name: required for volumes, optional for env vars
					containerName?: string

					// Specifies the output format of the exposed resources, defaults
					// to "1"
					divisor?: (int | string) & {
						=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Required: resource to select
					resource: string
				}

				// Selects a key of a secret in the pod's namespace
				secretKeyRef?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}
		}]

		// List of sources to populate environment variables in the
		// container. The keys defined within a source must be a
		// C_IDENTIFIER. All invalid keys will be reported as an event
		// when the container is starting. When a key exists in multiple
		// sources, the value associated with the last source will take
		// precedence. Values defined by an Env with a duplicate key will
		// take precedence. Cannot be updated.
		envFrom?: [...{
			// The ConfigMap to select from
			configMapRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the ConfigMap must be defined
				optional?: bool
			}

			// An optional identifier to prepend to each key in the ConfigMap.
			// Must be a C_IDENTIFIER.
			prefix?: string

			// The Secret to select from
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret must be defined
				optional?: bool
			}
		}]

		// Container image name. More info:
		// https://kubernetes.io/docs/concepts/containers/images This
		// field is optional to allow higher level config management to
		// default or override container images in workload controllers
		// like Deployments and StatefulSets.
		image?: string

		// Image pull policy. One of Always, Never, IfNotPresent. Defaults
		// to Always if :latest tag is specified, or IfNotPresent
		// otherwise. Cannot be updated. More info:
		// https://kubernetes.io/docs/concepts/containers/images#updating-images
		imagePullPolicy?: string

		// Actions that the management system should take in response to
		// container lifecycle events. Cannot be updated.
		lifecycle?: {
			// PostStart is called immediately after a container is created.
			// If the handler fails, the container is terminated and
			// restarted according to its restart policy. Other management of
			// the container blocks until the hook completes. More info:
			// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
			postStart?: {
				exec?: {
					// Command is the command line to execute inside the container,
					// the working directory for the command is root ('/') in the
					// container's filesystem. The command is simply exec'd, it is
					// not run inside a shell, so traditional shell instructions
					// ('|', etc) won't work. To use a shell, you need to explicitly
					// call out to that shell. Exit status of 0 is treated as
					// live/healthy and non-zero is unhealthy.
					command?: [...string]
				}

				// HTTPGet specifies the http request to perform.
				httpGet?: {
					// Host name to connect to, defaults to the pod IP. You probably
					// want to set "Host" in httpHeaders instead.
					host?: string

					// Custom headers to set in the request. HTTP allows repeated
					// headers.
					httpHeaders?: [...{
						// The header field name. This will be canonicalized upon output,
						// so case-variant names will be understood as the same header.
						name: string

						// The header field value
						value: string
					}]

					// Path to access on the HTTP server.
					path?: string

					// Name or number of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}

					// Scheme to use for connecting to the host. Defaults to HTTP.
					scheme?: string
				}
				sleep?: {
					// Seconds is the number of seconds to sleep.
					seconds: int
				}

				// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
				// and kept for the backward compatibility. There are no
				// validation of this field and lifecycle hooks will fail in
				// runtime when tcp handler is specified.
				tcpSocket?: {
					// Optional: Host name to connect to, defaults to the pod IP.
					host?: string

					// Number or name of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}
				}
			}

			// PreStop is called immediately before a container is terminated
			// due to an API request or management event such as
			// liveness/startup probe failure, preemption, resource
			// contention, etc. The handler is not called if the container
			// crashes or exits. The Pod's termination grace period countdown
			// begins before the PreStop hook is executed. Regardless of the
			// outcome of the handler, the container will eventually
			// terminate within the Pod's termination grace period (unless
			// delayed by finalizers). Other management of the container
			// blocks until the hook completes or until the termination grace
			// period is reached. More info:
			// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
			preStop?: {
				exec?: {
					// Command is the command line to execute inside the container,
					// the working directory for the command is root ('/') in the
					// container's filesystem. The command is simply exec'd, it is
					// not run inside a shell, so traditional shell instructions
					// ('|', etc) won't work. To use a shell, you need to explicitly
					// call out to that shell. Exit status of 0 is treated as
					// live/healthy and non-zero is unhealthy.
					command?: [...string]
				}

				// HTTPGet specifies the http request to perform.
				httpGet?: {
					// Host name to connect to, defaults to the pod IP. You probably
					// want to set "Host" in httpHeaders instead.
					host?: string

					// Custom headers to set in the request. HTTP allows repeated
					// headers.
					httpHeaders?: [...{
						// The header field name. This will be canonicalized upon output,
						// so case-variant names will be understood as the same header.
						name: string

						// The header field value
						value: string
					}]

					// Path to access on the HTTP server.
					path?: string

					// Name or number of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}

					// Scheme to use for connecting to the host. Defaults to HTTP.
					scheme?: string
				}
				sleep?: {
					// Seconds is the number of seconds to sleep.
					seconds: int
				}

				// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
				// and kept for the backward compatibility. There are no
				// validation of this field and lifecycle hooks will fail in
				// runtime when tcp handler is specified.
				tcpSocket?: {
					// Optional: Host name to connect to, defaults to the pod IP.
					host?: string

					// Number or name of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}
				}
			}
		}

		// Periodic probe of container liveness. Container will be
		// restarted if the probe fails. Cannot be updated. More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
		livenessProbe?: {
			exec?: {
				// Command is the command line to execute inside the container,
				// the working directory for the command is root ('/') in the
				// container's filesystem. The command is simply exec'd, it is
				// not run inside a shell, so traditional shell instructions
				// ('|', etc) won't work. To use a shell, you need to explicitly
				// call out to that shell. Exit status of 0 is treated as
				// live/healthy and non-zero is unhealthy.
				command?: [...string]
			}

			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: int

			// GRPC specifies an action involving a GRPC port.
			grpc?: {
				// Port number of the gRPC service. Number must be in the range 1
				// to 65535.
				port: int

				// Service is the name of the service to place in the gRPC
				// HealthCheckRequest (see
				// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
				// If this is not specified, the default behavior is defined by
				// gRPC.
				service?: string
			}

			// HTTPGet specifies the http request to perform.
			httpGet?: {
				// Host name to connect to, defaults to the pod IP. You probably
				// want to set "Host" in httpHeaders instead.
				host?: string

				// Custom headers to set in the request. HTTP allows repeated
				// headers.
				httpHeaders?: [...{
					// The header field name. This will be canonicalized upon output,
					// so case-variant names will be understood as the same header.
					name: string

					// The header field value
					value: string
				}]

				// Path to access on the HTTP server.
				path?: string

				// Name or number of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}

				// Scheme to use for connecting to the host. Defaults to HTTP.
				scheme?: string
			}

			// Number of seconds after the container has started before
			// liveness probes are initiated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			initialDelaySeconds?: int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness and startup. Minimum value is 1.
			successThreshold?: int

			// TCPSocket specifies an action involving a TCP port.
			tcpSocket?: {
				// Optional: Host name to connect to, defaults to the pod IP.
				host?: string

				// Number or name of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}
			}

			// Optional duration in seconds the pod needs to terminate
			// gracefully upon probe failure. The grace period is the
			// duration in seconds after the processes running in the pod are
			// sent a termination signal and the time when the processes are
			// forcibly halted with a kill signal. Set this value longer than
			// the expected cleanup time for your process. If this value is
			// nil, the pod's terminationGracePeriodSeconds will be used.
			// Otherwise, this value overrides the value provided by the pod
			// spec. Value must be non-negative integer. The value zero
			// indicates stop immediately via the kill signal (no opportunity
			// to shut down). This is a beta field and requires enabling
			// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
			// spec.terminationGracePeriodSeconds is used if unset.
			terminationGracePeriodSeconds?: int

			// Number of seconds after which the probe times out. Defaults to
			// 1 second. Minimum value is 1. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			timeoutSeconds?: int
		}

		// Name of the container specified as a DNS_LABEL. Each container
		// in a pod must have a unique name (DNS_LABEL). Cannot be
		// updated.
		name: string

		// List of ports to expose from the container. Not specifying a
		// port here DOES NOT prevent that port from being exposed. Any
		// port which is listening on the default "0.0.0.0" address
		// inside a container will be accessible from the network.
		// Modifying this array with strategic merge patch may corrupt
		// the data. For more information See
		// https://github.com/kubernetes/kubernetes/issues/108255. Cannot
		// be updated.
		ports?: [...{
			// Number of port to expose on the pod's IP address. This must be
			// a valid port number, 0 < x < 65536.
			containerPort: int

			// What host IP to bind the external port to.
			hostIP?: string

			// Number of port to expose on the host. If specified, this must
			// be a valid port number, 0 < x < 65536. If HostNetwork is
			// specified, this must match ContainerPort. Most containers do
			// not need this.
			hostPort?: int

			// If specified, this must be an IANA_SVC_NAME and unique within
			// the pod. Each named port in a pod must have a unique name.
			// Name for the port that can be referred to by services.
			name?: string

			// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to
			// "TCP".
			protocol?: string | *"TCP"
		}]

		// Periodic probe of container service readiness. Container will
		// be removed from service endpoints if the probe fails. Cannot
		// be updated. More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
		readinessProbe?: {
			exec?: {
				// Command is the command line to execute inside the container,
				// the working directory for the command is root ('/') in the
				// container's filesystem. The command is simply exec'd, it is
				// not run inside a shell, so traditional shell instructions
				// ('|', etc) won't work. To use a shell, you need to explicitly
				// call out to that shell. Exit status of 0 is treated as
				// live/healthy and non-zero is unhealthy.
				command?: [...string]
			}

			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: int

			// GRPC specifies an action involving a GRPC port.
			grpc?: {
				// Port number of the gRPC service. Number must be in the range 1
				// to 65535.
				port: int

				// Service is the name of the service to place in the gRPC
				// HealthCheckRequest (see
				// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
				// If this is not specified, the default behavior is defined by
				// gRPC.
				service?: string
			}

			// HTTPGet specifies the http request to perform.
			httpGet?: {
				// Host name to connect to, defaults to the pod IP. You probably
				// want to set "Host" in httpHeaders instead.
				host?: string

				// Custom headers to set in the request. HTTP allows repeated
				// headers.
				httpHeaders?: [...{
					// The header field name. This will be canonicalized upon output,
					// so case-variant names will be understood as the same header.
					name: string

					// The header field value
					value: string
				}]

				// Path to access on the HTTP server.
				path?: string

				// Name or number of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}

				// Scheme to use for connecting to the host. Defaults to HTTP.
				scheme?: string
			}

			// Number of seconds after the container has started before
			// liveness probes are initiated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			initialDelaySeconds?: int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness and startup. Minimum value is 1.
			successThreshold?: int

			// TCPSocket specifies an action involving a TCP port.
			tcpSocket?: {
				// Optional: Host name to connect to, defaults to the pod IP.
				host?: string

				// Number or name of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}
			}

			// Optional duration in seconds the pod needs to terminate
			// gracefully upon probe failure. The grace period is the
			// duration in seconds after the processes running in the pod are
			// sent a termination signal and the time when the processes are
			// forcibly halted with a kill signal. Set this value longer than
			// the expected cleanup time for your process. If this value is
			// nil, the pod's terminationGracePeriodSeconds will be used.
			// Otherwise, this value overrides the value provided by the pod
			// spec. Value must be non-negative integer. The value zero
			// indicates stop immediately via the kill signal (no opportunity
			// to shut down). This is a beta field and requires enabling
			// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
			// spec.terminationGracePeriodSeconds is used if unset.
			terminationGracePeriodSeconds?: int

			// Number of seconds after which the probe times out. Defaults to
			// 1 second. Minimum value is 1. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			timeoutSeconds?: int
		}

		// Resources resize policy for the container.
		resizePolicy?: [...{
			// Name of the resource to which this resource resize policy
			// applies. Supported values: cpu, memory.
			resourceName: string

			// Restart policy to apply when specified resource is resized. If
			// not specified, it defaults to NotRequired.
			restartPolicy: string
		}]

		// Compute Resources required by this container. Cannot be
		// updated. More info:
		// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
		resources?: {
			// Claims lists the names of resources, defined in
			// spec.resourceClaims, that are used by this container.
			// This is an alpha field and requires enabling the
			// DynamicResourceAllocation feature gate.
			// This field is immutable. It can only be set for containers.
			claims?: [...{
				// Name must match the name of one entry in
				// pod.spec.resourceClaims of the Pod where this field is used.
				// It makes that resource available inside a container.
				name: string
			}]

			// Limits describes the maximum amount of compute resources
			// allowed. More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
			limits?: {
				[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}

			// Requests describes the minimum amount of compute resources
			// required. If Requests is omitted for a container, it defaults
			// to Limits if that is explicitly specified, otherwise to an
			// implementation-defined value. Requests cannot exceed Limits.
			// More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
			requests?: {
				[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}
		}

		// RestartPolicy defines the restart behavior of individual
		// containers in a pod. This field may only be set for init
		// containers, and the only allowed value is "Always". For
		// non-init containers or when this field is not specified, the
		// restart behavior is defined by the Pod's restart policy and
		// the container type. Setting the RestartPolicy as "Always" for
		// the init container will have the following effect: this init
		// container will be continually restarted on exit until all
		// regular containers have terminated. Once all regular
		// containers have completed, all init containers with
		// restartPolicy "Always" will be shut down. This lifecycle
		// differs from normal init containers and is often referred to
		// as a "sidecar" container. Although this init container still
		// starts in the init container sequence, it does not wait for
		// the container to complete before proceeding to the next init
		// container. Instead, the next init container starts immediately
		// after this init container is started, or after any
		// startupProbe has successfully completed.
		restartPolicy?: string

		// SecurityContext defines the security options the container
		// should be run with. If set, the fields of SecurityContext
		// override the equivalent fields of PodSecurityContext. More
		// info:
		// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
		securityContext?: {
			// AllowPrivilegeEscalation controls whether a process can gain
			// more privileges than its parent process. This bool directly
			// controls if the no_new_privs flag will be set on the container
			// process. AllowPrivilegeEscalation is true always when the
			// container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note
			// that this field cannot be set when spec.os.name is windows.
			allowPrivilegeEscalation?: bool

			// The capabilities to add/drop when running containers. Defaults
			// to the default set of capabilities granted by the container
			// runtime. Note that this field cannot be set when spec.os.name
			// is windows.
			capabilities?: {
				// Added capabilities
				add?: [...string]

				// Removed capabilities
				drop?: [...string]
			}

			// Run container in privileged mode. Processes in privileged
			// containers are essentially equivalent to root on the host.
			// Defaults to false. Note that this field cannot be set when
			// spec.os.name is windows.
			privileged?: bool

			// procMount denotes the type of proc mount to use for the
			// containers. The default is DefaultProcMount which uses the
			// container runtime defaults for readonly paths and masked
			// paths. This requires the ProcMountType feature flag to be
			// enabled. Note that this field cannot be set when spec.os.name
			// is windows.
			procMount?: string

			// Whether this container has a read-only root filesystem. Default
			// is false. Note that this field cannot be set when spec.os.name
			// is windows.
			readOnlyRootFilesystem?: bool

			// The GID to run the entrypoint of the container process. Uses
			// runtime default if unset. May also be set in
			// PodSecurityContext. If set in both SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence. Note that this field cannot be set when
			// spec.os.name is windows.
			runAsGroup?: int

			// Indicates that the container must run as a non-root user. If
			// true, the Kubelet will validate the image at runtime to ensure
			// that it does not run as UID 0 (root) and fail to start the
			// container if it does. If unset or false, no such validation
			// will be performed. May also be set in PodSecurityContext. If
			// set in both SecurityContext and PodSecurityContext, the value
			// specified in SecurityContext takes precedence.
			runAsNonRoot?: bool

			// The UID to run the entrypoint of the container process.
			// Defaults to user specified in image metadata if unspecified.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and PodSecurityContext, the value specified in
			// SecurityContext takes precedence. Note that this field cannot
			// be set when spec.os.name is windows.
			runAsUser?: int

			// The SELinux context to be applied to the container. If
			// unspecified, the container runtime will allocate a random
			// SELinux context for each container. May also be set in
			// PodSecurityContext. If set in both SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence. Note that this field cannot be set when
			// spec.os.name is windows.
			seLinuxOptions?: {
				// Level is SELinux level label that applies to the container.
				level?: string

				// Role is a SELinux role label that applies to the container.
				role?: string

				// Type is a SELinux type label that applies to the container.
				type?: string

				// User is a SELinux user label that applies to the container.
				user?: string
			}

			// The seccomp options to use by this container. If seccomp
			// options are provided at both the pod & container level, the
			// container options override the pod options. Note that this
			// field cannot be set when spec.os.name is windows.
			seccompProfile?: {
				// localhostProfile indicates a profile defined in a file on the
				// node should be used. The profile must be preconfigured on the
				// node to work. Must be a descending path, relative to the
				// kubelet's configured seccomp profile location. Must be set if
				// type is "Localhost". Must NOT be set for any other type.
				localhostProfile?: string

				// type indicates which kind of seccomp profile will be applied.
				// Valid options are:
				// Localhost - a profile defined in a file on the node should be
				// used. RuntimeDefault - the container runtime default profile
				// should be used. Unconfined - no profile should be applied.
				type: string
			}

			// The Windows specific settings applied to all containers. If
			// unspecified, the options from the PodSecurityContext will be
			// used. If set in both SecurityContext and PodSecurityContext,
			// the value specified in SecurityContext takes precedence. Note
			// that this field cannot be set when spec.os.name is linux.
			windowsOptions?: {
				// GMSACredentialSpec is where the GMSA admission webhook
				// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
				// contents of the GMSA credential spec named by the
				// GMSACredentialSpecName field.
				gmsaCredentialSpec?: string

				// GMSACredentialSpecName is the name of the GMSA credential spec
				// to use.
				gmsaCredentialSpecName?: string

				// HostProcess determines if a container should be run as a 'Host
				// Process' container. All of a Pod's containers must have the
				// same effective HostProcess value (it is not allowed to have a
				// mix of HostProcess containers and non-HostProcess containers).
				// In addition, if HostProcess is true then HostNetwork must also
				// be set to true.
				hostProcess?: bool

				// The UserName in Windows to run the entrypoint of the container
				// process. Defaults to the user specified in image metadata if
				// unspecified. May also be set in PodSecurityContext. If set in
				// both SecurityContext and PodSecurityContext, the value
				// specified in SecurityContext takes precedence.
				runAsUserName?: string
			}
		}

		// StartupProbe indicates that the Pod has successfully
		// initialized. If specified, no other probes are executed until
		// this completes successfully. If this probe fails, the Pod will
		// be restarted, just as if the livenessProbe failed. This can be
		// used to provide different probe parameters at the beginning of
		// a Pod's lifecycle, when it might take a long time to load data
		// or warm a cache, than during steady-state operation. This
		// cannot be updated. More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
		startupProbe?: {
			exec?: {
				// Command is the command line to execute inside the container,
				// the working directory for the command is root ('/') in the
				// container's filesystem. The command is simply exec'd, it is
				// not run inside a shell, so traditional shell instructions
				// ('|', etc) won't work. To use a shell, you need to explicitly
				// call out to that shell. Exit status of 0 is treated as
				// live/healthy and non-zero is unhealthy.
				command?: [...string]
			}

			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: int

			// GRPC specifies an action involving a GRPC port.
			grpc?: {
				// Port number of the gRPC service. Number must be in the range 1
				// to 65535.
				port: int

				// Service is the name of the service to place in the gRPC
				// HealthCheckRequest (see
				// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
				// If this is not specified, the default behavior is defined by
				// gRPC.
				service?: string
			}

			// HTTPGet specifies the http request to perform.
			httpGet?: {
				// Host name to connect to, defaults to the pod IP. You probably
				// want to set "Host" in httpHeaders instead.
				host?: string

				// Custom headers to set in the request. HTTP allows repeated
				// headers.
				httpHeaders?: [...{
					// The header field name. This will be canonicalized upon output,
					// so case-variant names will be understood as the same header.
					name: string

					// The header field value
					value: string
				}]

				// Path to access on the HTTP server.
				path?: string

				// Name or number of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}

				// Scheme to use for connecting to the host. Defaults to HTTP.
				scheme?: string
			}

			// Number of seconds after the container has started before
			// liveness probes are initiated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			initialDelaySeconds?: int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness and startup. Minimum value is 1.
			successThreshold?: int

			// TCPSocket specifies an action involving a TCP port.
			tcpSocket?: {
				// Optional: Host name to connect to, defaults to the pod IP.
				host?: string

				// Number or name of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}
			}

			// Optional duration in seconds the pod needs to terminate
			// gracefully upon probe failure. The grace period is the
			// duration in seconds after the processes running in the pod are
			// sent a termination signal and the time when the processes are
			// forcibly halted with a kill signal. Set this value longer than
			// the expected cleanup time for your process. If this value is
			// nil, the pod's terminationGracePeriodSeconds will be used.
			// Otherwise, this value overrides the value provided by the pod
			// spec. Value must be non-negative integer. The value zero
			// indicates stop immediately via the kill signal (no opportunity
			// to shut down). This is a beta field and requires enabling
			// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
			// spec.terminationGracePeriodSeconds is used if unset.
			terminationGracePeriodSeconds?: int

			// Number of seconds after which the probe times out. Defaults to
			// 1 second. Minimum value is 1. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			timeoutSeconds?: int
		}

		// Whether this container should allocate a buffer for stdin in
		// the container runtime. If this is not set, reads from stdin in
		// the container will always result in EOF. Default is false.
		stdin?: bool

		// Whether the container runtime should close the stdin channel
		// after it has been opened by a single attach. When stdin is
		// true the stdin stream will remain open across multiple attach
		// sessions. If stdinOnce is set to true, stdin is opened on
		// container start, is empty until the first client attaches to
		// stdin, and then remains open and accepts data until the client
		// disconnects, at which time stdin is closed and remains closed
		// until the container is restarted. If this flag is false, a
		// container processes that reads from stdin will never receive
		// an EOF. Default is false
		stdinOnce?: bool

		// Optional: Path at which the file to which the container's
		// termination message will be written is mounted into the
		// container's filesystem. Message written is intended to be
		// brief final status, such as an assertion failure message. Will
		// be truncated by the node if greater than 4096 bytes. The total
		// message length across all containers will be limited to 12kb.
		// Defaults to /dev/termination-log. Cannot be updated.
		terminationMessagePath?: string

		// Indicate how the termination message should be populated. File
		// will use the contents of terminationMessagePath to populate
		// the container status message on both success and failure.
		// FallbackToLogsOnError will use the last chunk of container log
		// output if the termination message file is empty and the
		// container exited with an error. The log output is limited to
		// 2048 bytes or 80 lines, whichever is smaller. Defaults to
		// File. Cannot be updated.
		terminationMessagePolicy?: string

		// Whether this container should allocate a TTY for itself, also
		// requires 'stdin' to be true. Default is false.
		tty?: bool

		// volumeDevices is the list of block devices to be used by the
		// container.
		volumeDevices?: [...{
			// devicePath is the path inside of the container that the device
			// will be mapped to.
			devicePath: string

			// name must match the name of a persistentVolumeClaim in the pod
			name: string
		}]

		// Pod volumes to mount into the container's filesystem. Cannot be
		// updated.
		volumeMounts?: [...{
			// Path within the container at which the volume should be
			// mounted. Must not contain ':'.
			mountPath: string

			// mountPropagation determines how mounts are propagated from the
			// host to container and the other way around. When not set,
			// MountPropagationNone is used. This field is beta in 1.10.
			mountPropagation?: string

			// This must match the Name of a Volume.
			name: string

			// Mounted read-only if true, read-write otherwise (false or
			// unspecified). Defaults to false.
			readOnly?: bool

			// Path within the volume from which the container's volume should
			// be mounted. Defaults to "" (volume's root).
			subPath?: string

			// Expanded path within the volume from which the container's
			// volume should be mounted. Behaves similarly to SubPath but
			// environment variable references $(VAR_NAME) are expanded using
			// the container's environment. Defaults to "" (volume's root).
			// SubPathExpr and SubPath are mutually exclusive.
			subPathExpr?: string
		}]

		// Container's working directory. If not specified, the container
		// runtime's default will be used, which might be configured in
		// the container image. Cannot be updated.
		workingDir?: string
	}]

	// Enable access to Prometheus feature flags. By default, no
	// features are enabled.
	// Enabling features which are disabled by default is entirely
	// outside the scope of what the maintainers will support and by
	// doing so, you accept that this behaviour may break at any time
	// without notice.
	// For more information see
	// https://prometheus.io/docs/prometheus/latest/feature_flags/
	enableFeatures?: [...string]

	// Enable Prometheus to be used as a receiver for the Prometheus
	// remote write protocol.
	// WARNING: This is not considered an efficient way of ingesting
	// samples. Use it with caution for specific low-volume use
	// cases. It is not suitable for replacing the ingestion via
	// scraping and turning Prometheus into a push-based metrics
	// collection system. For more information see
	// https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver
	// It requires Prometheus >= v2.33.0.
	enableRemoteWriteReceiver?: bool

	// When defined, enforcedBodySizeLimit specifies a global limit on
	// the size of uncompressed response body that will be accepted
	// by Prometheus. Targets responding with a body larger than this
	// many bytes will cause the scrape to fail.
	// It requires Prometheus >= v2.28.0.
	enforcedBodySizeLimit?: =~"(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"

	// When defined, enforcedKeepDroppedTargets specifies a global
	// limit on the number of targets dropped by relabeling that will
	// be kept in memory. The value overrides any
	// `spec.keepDroppedTargets` set by ServiceMonitor, PodMonitor,
	// Probe objects unless `spec.keepDroppedTargets` is greater than
	// zero and less than `spec.enforcedKeepDroppedTargets`.
	// It requires Prometheus >= v2.47.0.
	enforcedKeepDroppedTargets?: int

	// When defined, enforcedLabelLimit specifies a global limit on
	// the number of labels per sample. The value overrides any
	// `spec.labelLimit` set by ServiceMonitor, PodMonitor, Probe
	// objects unless `spec.labelLimit` is greater than zero and less
	// than `spec.enforcedLabelLimit`.
	// It requires Prometheus >= v2.27.0.
	enforcedLabelLimit?: int

	// When defined, enforcedLabelNameLengthLimit specifies a global
	// limit on the length of labels name per sample. The value
	// overrides any `spec.labelNameLengthLimit` set by
	// ServiceMonitor, PodMonitor, Probe objects unless
	// `spec.labelNameLengthLimit` is greater than zero and less than
	// `spec.enforcedLabelNameLengthLimit`.
	// It requires Prometheus >= v2.27.0.
	enforcedLabelNameLengthLimit?: int

	// When not null, enforcedLabelValueLengthLimit defines a global
	// limit on the length of labels value per sample. The value
	// overrides any `spec.labelValueLengthLimit` set by
	// ServiceMonitor, PodMonitor, Probe objects unless
	// `spec.labelValueLengthLimit` is greater than zero and less
	// than `spec.enforcedLabelValueLengthLimit`.
	// It requires Prometheus >= v2.27.0.
	enforcedLabelValueLengthLimit?: int

	// When not empty, a label will be added to
	// 1. All metrics scraped from `ServiceMonitor`, `PodMonitor`,
	// `Probe` and `ScrapeConfig` objects. 2. All metrics generated
	// from recording rules defined in `PrometheusRule` objects. 3.
	// All alerts generated from alerting rules defined in
	// `PrometheusRule` objects. 4. All vector selectors of PromQL
	// expressions defined in `PrometheusRule` objects.
	// The label will not added for objects referenced in
	// `spec.excludedFromEnforcement`.
	// The label's name is this field's value. The label's value is
	// the namespace of the `ServiceMonitor`, `PodMonitor`, `Probe`
	// or `PrometheusRule` object.
	enforcedNamespaceLabel?: string

	// When defined, enforcedSampleLimit specifies a global limit on
	// the number of scraped samples that will be accepted. This
	// overrides any `spec.sampleLimit` set by ServiceMonitor,
	// PodMonitor, Probe objects unless `spec.sampleLimit` is greater
	// than zero and less than than `spec.enforcedSampleLimit`.
	// It is meant to be used by admins to keep the overall number of
	// samples/series under a desired limit.
	enforcedSampleLimit?: int

	// When defined, enforcedTargetLimit specifies a global limit on
	// the number of scraped targets. The value overrides any
	// `spec.targetLimit` set by ServiceMonitor, PodMonitor, Probe
	// objects unless `spec.targetLimit` is greater than zero and
	// less than `spec.enforcedTargetLimit`.
	// It is meant to be used by admins to to keep the overall number
	// of targets under a desired limit.
	enforcedTargetLimit?: int

	// List of references to PodMonitor, ServiceMonitor, Probe and
	// PrometheusRule objects to be excluded from enforcing a
	// namespace label of origin.
	// It is only applicable if `spec.enforcedNamespaceLabel` set to
	// true.
	excludedFromEnforcement?: [...{
		// Group of the referent. When not specified, it defaults to
		// `monitoring.coreos.com`
		group?: "monitoring.coreos.com" | *"monitoring.coreos.com"

		// Name of the referent. When not set, all resources in the
		// namespace are matched.
		name?: string

		// Namespace of the referent. More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
		namespace: strings.MinRunes(1)

		// Resource of the referent.
		resource: "prometheusrules" | "servicemonitors" | "podmonitors" | "probes" | "scrapeconfigs"
	}]

	// The labels to add to any time series or alerts when
	// communicating with external systems (federation, remote
	// storage, Alertmanager). Labels defined by
	// `spec.replicaExternalLabelName` and
	// `spec.prometheusExternalLabelName` take precedence over this
	// list.
	externalLabels?: {
		[string]: string
	}

	// The external URL under which the Prometheus service is
	// externally available. This is necessary to generate correct
	// URLs (for instance if Prometheus is accessible behind an
	// Ingress resource).
	externalUrl?: string

	// Optional list of hosts and IPs that will be injected into the
	// Pod's hosts file if specified.
	hostAliases?: [...{
		// Hostnames for the above IP address.
		hostnames: [...string]

		// IP address of the host file entry.
		ip: string
	}]

	// Use the host's network namespace if true.
	// Make sure to understand the security implications if you want
	// to enable it
	// (https://kubernetes.io/docs/concepts/configuration/overview/).
	// When hostNetwork is enabled, this will set the DNS policy to
	// `ClusterFirstWithHostNet` automatically.
	hostNetwork?: bool

	// When true, `spec.namespaceSelector` from all PodMonitor,
	// ServiceMonitor and Probe objects will be ignored. They will
	// only discover targets within the namespace of the PodMonitor,
	// ServiceMonitor and Probe object.
	ignoreNamespaceSelectors?: bool

	// Container image name for Prometheus. If specified, it takes
	// precedence over the `spec.baseImage`, `spec.tag` and
	// `spec.sha` fields.
	// Specifying `spec.version` is still necessary to ensure the
	// Prometheus Operator knows which version of Prometheus is being
	// configured.
	// If neither `spec.image` nor `spec.baseImage` are defined, the
	// operator will use the latest upstream version of Prometheus
	// available at the time when the operator was released.
	image?: string

	// Image pull policy for the 'prometheus', 'init-config-reloader'
	// and 'config-reloader' containers. See
	// https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy
	// for more details.
	imagePullPolicy?: "" | "Always" | "Never" | "IfNotPresent"

	// An optional list of references to Secrets in the same namespace
	// to use for pulling images from registries. See
	// http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
	imagePullSecrets?: [...{
		// Name of the referent. More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		// TODO: Add other useful fields. apiVersion, kind, uid?
		name?: string
	}]

	// InitContainers allows injecting initContainers to the Pod
	// definition. Those can be used to e.g. fetch secrets for
	// injection into the Prometheus configuration from external
	// sources. Any errors during the execution of an initContainer
	// will lead to a restart of the Pod. More info:
	// https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// InitContainers described here modify an operator generated
	// init containers if they share the same name and modifications
	// are done via a strategic merge patch.
	// The names of init container name managed by the operator are: *
	// `init-config-reloader`.
	// Overriding init containers is entirely outside the scope of
	// what the maintainers will support and by doing so, you accept
	// that this behaviour may break at any time without notice.
	initContainers?: [...{
		// Arguments to the entrypoint. The container image's CMD is used
		// if this is not provided. Variable references $(VAR_NAME) are
		// expanded using the container's environment. If a variable
		// cannot be resolved, the reference in the input string will be
		// unchanged. Double $$ are reduced to a single $, which allows
		// for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
		// produce the string literal "$(VAR_NAME)". Escaped references
		// will never be expanded, regardless of whether the variable
		// exists or not. Cannot be updated. More info:
		// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
		args?: [...string]

		// Entrypoint array. Not executed within a shell. The container
		// image's ENTRYPOINT is used if this is not provided. Variable
		// references $(VAR_NAME) are expanded using the container's
		// environment. If a variable cannot be resolved, the reference
		// in the input string will be unchanged. Double $$ are reduced
		// to a single $, which allows for escaping the $(VAR_NAME)
		// syntax: i.e. "$$(VAR_NAME)" will produce the string literal
		// "$(VAR_NAME)". Escaped references will never be expanded,
		// regardless of whether the variable exists or not. Cannot be
		// updated. More info:
		// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
		command?: [...string]

		// List of environment variables to set in the container. Cannot
		// be updated.
		env?: [...{
			// Name of the environment variable. Must be a C_IDENTIFIER.
			name: string

			// Variable references $(VAR_NAME) are expanded using the
			// previously defined environment variables in the container and
			// any service environment variables. If a variable cannot be
			// resolved, the reference in the input string will be unchanged.
			// Double $$ are reduced to a single $, which allows for escaping
			// the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the
			// string literal "$(VAR_NAME)". Escaped references will never be
			// expanded, regardless of whether the variable exists or not.
			// Defaults to "".
			value?: string

			// Source for the environment variable's value. Cannot be used if
			// value is not empty.
			valueFrom?: {
				// Selects a key of a ConfigMap.
				configMapKeyRef?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Selects a field of the pod: supports metadata.name,
				// metadata.namespace, `metadata.labels['<KEY>']`,
				// `metadata.annotations['<KEY>']`, spec.nodeName,
				// spec.serviceAccountName, status.hostIP, status.podIP,
				// status.podIPs.
				fieldRef?: {
					// Version of the schema the FieldPath is written in terms of,
					// defaults to "v1".
					apiVersion?: string

					// Path of the field to select in the specified API version.
					fieldPath: string
				}

				// Selects a resource of the container: only resources limits and
				// requests (limits.cpu, limits.memory, limits.ephemeral-storage,
				// requests.cpu, requests.memory and requests.ephemeral-storage)
				// are currently supported.
				resourceFieldRef?: {
					// Container name: required for volumes, optional for env vars
					containerName?: string

					// Specifies the output format of the exposed resources, defaults
					// to "1"
					divisor?: (int | string) & {
						=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Required: resource to select
					resource: string
				}

				// Selects a key of a secret in the pod's namespace
				secretKeyRef?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}
		}]

		// List of sources to populate environment variables in the
		// container. The keys defined within a source must be a
		// C_IDENTIFIER. All invalid keys will be reported as an event
		// when the container is starting. When a key exists in multiple
		// sources, the value associated with the last source will take
		// precedence. Values defined by an Env with a duplicate key will
		// take precedence. Cannot be updated.
		envFrom?: [...{
			// The ConfigMap to select from
			configMapRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the ConfigMap must be defined
				optional?: bool
			}

			// An optional identifier to prepend to each key in the ConfigMap.
			// Must be a C_IDENTIFIER.
			prefix?: string

			// The Secret to select from
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret must be defined
				optional?: bool
			}
		}]

		// Container image name. More info:
		// https://kubernetes.io/docs/concepts/containers/images This
		// field is optional to allow higher level config management to
		// default or override container images in workload controllers
		// like Deployments and StatefulSets.
		image?: string

		// Image pull policy. One of Always, Never, IfNotPresent. Defaults
		// to Always if :latest tag is specified, or IfNotPresent
		// otherwise. Cannot be updated. More info:
		// https://kubernetes.io/docs/concepts/containers/images#updating-images
		imagePullPolicy?: string

		// Actions that the management system should take in response to
		// container lifecycle events. Cannot be updated.
		lifecycle?: {
			// PostStart is called immediately after a container is created.
			// If the handler fails, the container is terminated and
			// restarted according to its restart policy. Other management of
			// the container blocks until the hook completes. More info:
			// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
			postStart?: {
				exec?: {
					// Command is the command line to execute inside the container,
					// the working directory for the command is root ('/') in the
					// container's filesystem. The command is simply exec'd, it is
					// not run inside a shell, so traditional shell instructions
					// ('|', etc) won't work. To use a shell, you need to explicitly
					// call out to that shell. Exit status of 0 is treated as
					// live/healthy and non-zero is unhealthy.
					command?: [...string]
				}

				// HTTPGet specifies the http request to perform.
				httpGet?: {
					// Host name to connect to, defaults to the pod IP. You probably
					// want to set "Host" in httpHeaders instead.
					host?: string

					// Custom headers to set in the request. HTTP allows repeated
					// headers.
					httpHeaders?: [...{
						// The header field name. This will be canonicalized upon output,
						// so case-variant names will be understood as the same header.
						name: string

						// The header field value
						value: string
					}]

					// Path to access on the HTTP server.
					path?: string

					// Name or number of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}

					// Scheme to use for connecting to the host. Defaults to HTTP.
					scheme?: string
				}
				sleep?: {
					// Seconds is the number of seconds to sleep.
					seconds: int
				}

				// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
				// and kept for the backward compatibility. There are no
				// validation of this field and lifecycle hooks will fail in
				// runtime when tcp handler is specified.
				tcpSocket?: {
					// Optional: Host name to connect to, defaults to the pod IP.
					host?: string

					// Number or name of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}
				}
			}

			// PreStop is called immediately before a container is terminated
			// due to an API request or management event such as
			// liveness/startup probe failure, preemption, resource
			// contention, etc. The handler is not called if the container
			// crashes or exits. The Pod's termination grace period countdown
			// begins before the PreStop hook is executed. Regardless of the
			// outcome of the handler, the container will eventually
			// terminate within the Pod's termination grace period (unless
			// delayed by finalizers). Other management of the container
			// blocks until the hook completes or until the termination grace
			// period is reached. More info:
			// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
			preStop?: {
				exec?: {
					// Command is the command line to execute inside the container,
					// the working directory for the command is root ('/') in the
					// container's filesystem. The command is simply exec'd, it is
					// not run inside a shell, so traditional shell instructions
					// ('|', etc) won't work. To use a shell, you need to explicitly
					// call out to that shell. Exit status of 0 is treated as
					// live/healthy and non-zero is unhealthy.
					command?: [...string]
				}

				// HTTPGet specifies the http request to perform.
				httpGet?: {
					// Host name to connect to, defaults to the pod IP. You probably
					// want to set "Host" in httpHeaders instead.
					host?: string

					// Custom headers to set in the request. HTTP allows repeated
					// headers.
					httpHeaders?: [...{
						// The header field name. This will be canonicalized upon output,
						// so case-variant names will be understood as the same header.
						name: string

						// The header field value
						value: string
					}]

					// Path to access on the HTTP server.
					path?: string

					// Name or number of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}

					// Scheme to use for connecting to the host. Defaults to HTTP.
					scheme?: string
				}
				sleep?: {
					// Seconds is the number of seconds to sleep.
					seconds: int
				}

				// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
				// and kept for the backward compatibility. There are no
				// validation of this field and lifecycle hooks will fail in
				// runtime when tcp handler is specified.
				tcpSocket?: {
					// Optional: Host name to connect to, defaults to the pod IP.
					host?: string

					// Number or name of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}
				}
			}
		}

		// Periodic probe of container liveness. Container will be
		// restarted if the probe fails. Cannot be updated. More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
		livenessProbe?: {
			exec?: {
				// Command is the command line to execute inside the container,
				// the working directory for the command is root ('/') in the
				// container's filesystem. The command is simply exec'd, it is
				// not run inside a shell, so traditional shell instructions
				// ('|', etc) won't work. To use a shell, you need to explicitly
				// call out to that shell. Exit status of 0 is treated as
				// live/healthy and non-zero is unhealthy.
				command?: [...string]
			}

			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: int

			// GRPC specifies an action involving a GRPC port.
			grpc?: {
				// Port number of the gRPC service. Number must be in the range 1
				// to 65535.
				port: int

				// Service is the name of the service to place in the gRPC
				// HealthCheckRequest (see
				// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
				// If this is not specified, the default behavior is defined by
				// gRPC.
				service?: string
			}

			// HTTPGet specifies the http request to perform.
			httpGet?: {
				// Host name to connect to, defaults to the pod IP. You probably
				// want to set "Host" in httpHeaders instead.
				host?: string

				// Custom headers to set in the request. HTTP allows repeated
				// headers.
				httpHeaders?: [...{
					// The header field name. This will be canonicalized upon output,
					// so case-variant names will be understood as the same header.
					name: string

					// The header field value
					value: string
				}]

				// Path to access on the HTTP server.
				path?: string

				// Name or number of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}

				// Scheme to use for connecting to the host. Defaults to HTTP.
				scheme?: string
			}

			// Number of seconds after the container has started before
			// liveness probes are initiated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			initialDelaySeconds?: int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness and startup. Minimum value is 1.
			successThreshold?: int

			// TCPSocket specifies an action involving a TCP port.
			tcpSocket?: {
				// Optional: Host name to connect to, defaults to the pod IP.
				host?: string

				// Number or name of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}
			}

			// Optional duration in seconds the pod needs to terminate
			// gracefully upon probe failure. The grace period is the
			// duration in seconds after the processes running in the pod are
			// sent a termination signal and the time when the processes are
			// forcibly halted with a kill signal. Set this value longer than
			// the expected cleanup time for your process. If this value is
			// nil, the pod's terminationGracePeriodSeconds will be used.
			// Otherwise, this value overrides the value provided by the pod
			// spec. Value must be non-negative integer. The value zero
			// indicates stop immediately via the kill signal (no opportunity
			// to shut down). This is a beta field and requires enabling
			// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
			// spec.terminationGracePeriodSeconds is used if unset.
			terminationGracePeriodSeconds?: int

			// Number of seconds after which the probe times out. Defaults to
			// 1 second. Minimum value is 1. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			timeoutSeconds?: int
		}

		// Name of the container specified as a DNS_LABEL. Each container
		// in a pod must have a unique name (DNS_LABEL). Cannot be
		// updated.
		name: string

		// List of ports to expose from the container. Not specifying a
		// port here DOES NOT prevent that port from being exposed. Any
		// port which is listening on the default "0.0.0.0" address
		// inside a container will be accessible from the network.
		// Modifying this array with strategic merge patch may corrupt
		// the data. For more information See
		// https://github.com/kubernetes/kubernetes/issues/108255. Cannot
		// be updated.
		ports?: [...{
			// Number of port to expose on the pod's IP address. This must be
			// a valid port number, 0 < x < 65536.
			containerPort: int

			// What host IP to bind the external port to.
			hostIP?: string

			// Number of port to expose on the host. If specified, this must
			// be a valid port number, 0 < x < 65536. If HostNetwork is
			// specified, this must match ContainerPort. Most containers do
			// not need this.
			hostPort?: int

			// If specified, this must be an IANA_SVC_NAME and unique within
			// the pod. Each named port in a pod must have a unique name.
			// Name for the port that can be referred to by services.
			name?: string

			// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to
			// "TCP".
			protocol?: string | *"TCP"
		}]

		// Periodic probe of container service readiness. Container will
		// be removed from service endpoints if the probe fails. Cannot
		// be updated. More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
		readinessProbe?: {
			exec?: {
				// Command is the command line to execute inside the container,
				// the working directory for the command is root ('/') in the
				// container's filesystem. The command is simply exec'd, it is
				// not run inside a shell, so traditional shell instructions
				// ('|', etc) won't work. To use a shell, you need to explicitly
				// call out to that shell. Exit status of 0 is treated as
				// live/healthy and non-zero is unhealthy.
				command?: [...string]
			}

			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: int

			// GRPC specifies an action involving a GRPC port.
			grpc?: {
				// Port number of the gRPC service. Number must be in the range 1
				// to 65535.
				port: int

				// Service is the name of the service to place in the gRPC
				// HealthCheckRequest (see
				// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
				// If this is not specified, the default behavior is defined by
				// gRPC.
				service?: string
			}

			// HTTPGet specifies the http request to perform.
			httpGet?: {
				// Host name to connect to, defaults to the pod IP. You probably
				// want to set "Host" in httpHeaders instead.
				host?: string

				// Custom headers to set in the request. HTTP allows repeated
				// headers.
				httpHeaders?: [...{
					// The header field name. This will be canonicalized upon output,
					// so case-variant names will be understood as the same header.
					name: string

					// The header field value
					value: string
				}]

				// Path to access on the HTTP server.
				path?: string

				// Name or number of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}

				// Scheme to use for connecting to the host. Defaults to HTTP.
				scheme?: string
			}

			// Number of seconds after the container has started before
			// liveness probes are initiated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			initialDelaySeconds?: int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness and startup. Minimum value is 1.
			successThreshold?: int

			// TCPSocket specifies an action involving a TCP port.
			tcpSocket?: {
				// Optional: Host name to connect to, defaults to the pod IP.
				host?: string

				// Number or name of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}
			}

			// Optional duration in seconds the pod needs to terminate
			// gracefully upon probe failure. The grace period is the
			// duration in seconds after the processes running in the pod are
			// sent a termination signal and the time when the processes are
			// forcibly halted with a kill signal. Set this value longer than
			// the expected cleanup time for your process. If this value is
			// nil, the pod's terminationGracePeriodSeconds will be used.
			// Otherwise, this value overrides the value provided by the pod
			// spec. Value must be non-negative integer. The value zero
			// indicates stop immediately via the kill signal (no opportunity
			// to shut down). This is a beta field and requires enabling
			// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
			// spec.terminationGracePeriodSeconds is used if unset.
			terminationGracePeriodSeconds?: int

			// Number of seconds after which the probe times out. Defaults to
			// 1 second. Minimum value is 1. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			timeoutSeconds?: int
		}

		// Resources resize policy for the container.
		resizePolicy?: [...{
			// Name of the resource to which this resource resize policy
			// applies. Supported values: cpu, memory.
			resourceName: string

			// Restart policy to apply when specified resource is resized. If
			// not specified, it defaults to NotRequired.
			restartPolicy: string
		}]

		// Compute Resources required by this container. Cannot be
		// updated. More info:
		// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
		resources?: {
			// Claims lists the names of resources, defined in
			// spec.resourceClaims, that are used by this container.
			// This is an alpha field and requires enabling the
			// DynamicResourceAllocation feature gate.
			// This field is immutable. It can only be set for containers.
			claims?: [...{
				// Name must match the name of one entry in
				// pod.spec.resourceClaims of the Pod where this field is used.
				// It makes that resource available inside a container.
				name: string
			}]

			// Limits describes the maximum amount of compute resources
			// allowed. More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
			limits?: {
				[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}

			// Requests describes the minimum amount of compute resources
			// required. If Requests is omitted for a container, it defaults
			// to Limits if that is explicitly specified, otherwise to an
			// implementation-defined value. Requests cannot exceed Limits.
			// More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
			requests?: {
				[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}
		}

		// RestartPolicy defines the restart behavior of individual
		// containers in a pod. This field may only be set for init
		// containers, and the only allowed value is "Always". For
		// non-init containers or when this field is not specified, the
		// restart behavior is defined by the Pod's restart policy and
		// the container type. Setting the RestartPolicy as "Always" for
		// the init container will have the following effect: this init
		// container will be continually restarted on exit until all
		// regular containers have terminated. Once all regular
		// containers have completed, all init containers with
		// restartPolicy "Always" will be shut down. This lifecycle
		// differs from normal init containers and is often referred to
		// as a "sidecar" container. Although this init container still
		// starts in the init container sequence, it does not wait for
		// the container to complete before proceeding to the next init
		// container. Instead, the next init container starts immediately
		// after this init container is started, or after any
		// startupProbe has successfully completed.
		restartPolicy?: string

		// SecurityContext defines the security options the container
		// should be run with. If set, the fields of SecurityContext
		// override the equivalent fields of PodSecurityContext. More
		// info:
		// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
		securityContext?: {
			// AllowPrivilegeEscalation controls whether a process can gain
			// more privileges than its parent process. This bool directly
			// controls if the no_new_privs flag will be set on the container
			// process. AllowPrivilegeEscalation is true always when the
			// container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note
			// that this field cannot be set when spec.os.name is windows.
			allowPrivilegeEscalation?: bool

			// The capabilities to add/drop when running containers. Defaults
			// to the default set of capabilities granted by the container
			// runtime. Note that this field cannot be set when spec.os.name
			// is windows.
			capabilities?: {
				// Added capabilities
				add?: [...string]

				// Removed capabilities
				drop?: [...string]
			}

			// Run container in privileged mode. Processes in privileged
			// containers are essentially equivalent to root on the host.
			// Defaults to false. Note that this field cannot be set when
			// spec.os.name is windows.
			privileged?: bool

			// procMount denotes the type of proc mount to use for the
			// containers. The default is DefaultProcMount which uses the
			// container runtime defaults for readonly paths and masked
			// paths. This requires the ProcMountType feature flag to be
			// enabled. Note that this field cannot be set when spec.os.name
			// is windows.
			procMount?: string

			// Whether this container has a read-only root filesystem. Default
			// is false. Note that this field cannot be set when spec.os.name
			// is windows.
			readOnlyRootFilesystem?: bool

			// The GID to run the entrypoint of the container process. Uses
			// runtime default if unset. May also be set in
			// PodSecurityContext. If set in both SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence. Note that this field cannot be set when
			// spec.os.name is windows.
			runAsGroup?: int

			// Indicates that the container must run as a non-root user. If
			// true, the Kubelet will validate the image at runtime to ensure
			// that it does not run as UID 0 (root) and fail to start the
			// container if it does. If unset or false, no such validation
			// will be performed. May also be set in PodSecurityContext. If
			// set in both SecurityContext and PodSecurityContext, the value
			// specified in SecurityContext takes precedence.
			runAsNonRoot?: bool

			// The UID to run the entrypoint of the container process.
			// Defaults to user specified in image metadata if unspecified.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and PodSecurityContext, the value specified in
			// SecurityContext takes precedence. Note that this field cannot
			// be set when spec.os.name is windows.
			runAsUser?: int

			// The SELinux context to be applied to the container. If
			// unspecified, the container runtime will allocate a random
			// SELinux context for each container. May also be set in
			// PodSecurityContext. If set in both SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence. Note that this field cannot be set when
			// spec.os.name is windows.
			seLinuxOptions?: {
				// Level is SELinux level label that applies to the container.
				level?: string

				// Role is a SELinux role label that applies to the container.
				role?: string

				// Type is a SELinux type label that applies to the container.
				type?: string

				// User is a SELinux user label that applies to the container.
				user?: string
			}

			// The seccomp options to use by this container. If seccomp
			// options are provided at both the pod & container level, the
			// container options override the pod options. Note that this
			// field cannot be set when spec.os.name is windows.
			seccompProfile?: {
				// localhostProfile indicates a profile defined in a file on the
				// node should be used. The profile must be preconfigured on the
				// node to work. Must be a descending path, relative to the
				// kubelet's configured seccomp profile location. Must be set if
				// type is "Localhost". Must NOT be set for any other type.
				localhostProfile?: string

				// type indicates which kind of seccomp profile will be applied.
				// Valid options are:
				// Localhost - a profile defined in a file on the node should be
				// used. RuntimeDefault - the container runtime default profile
				// should be used. Unconfined - no profile should be applied.
				type: string
			}

			// The Windows specific settings applied to all containers. If
			// unspecified, the options from the PodSecurityContext will be
			// used. If set in both SecurityContext and PodSecurityContext,
			// the value specified in SecurityContext takes precedence. Note
			// that this field cannot be set when spec.os.name is linux.
			windowsOptions?: {
				// GMSACredentialSpec is where the GMSA admission webhook
				// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
				// contents of the GMSA credential spec named by the
				// GMSACredentialSpecName field.
				gmsaCredentialSpec?: string

				// GMSACredentialSpecName is the name of the GMSA credential spec
				// to use.
				gmsaCredentialSpecName?: string

				// HostProcess determines if a container should be run as a 'Host
				// Process' container. All of a Pod's containers must have the
				// same effective HostProcess value (it is not allowed to have a
				// mix of HostProcess containers and non-HostProcess containers).
				// In addition, if HostProcess is true then HostNetwork must also
				// be set to true.
				hostProcess?: bool

				// The UserName in Windows to run the entrypoint of the container
				// process. Defaults to the user specified in image metadata if
				// unspecified. May also be set in PodSecurityContext. If set in
				// both SecurityContext and PodSecurityContext, the value
				// specified in SecurityContext takes precedence.
				runAsUserName?: string
			}
		}

		// StartupProbe indicates that the Pod has successfully
		// initialized. If specified, no other probes are executed until
		// this completes successfully. If this probe fails, the Pod will
		// be restarted, just as if the livenessProbe failed. This can be
		// used to provide different probe parameters at the beginning of
		// a Pod's lifecycle, when it might take a long time to load data
		// or warm a cache, than during steady-state operation. This
		// cannot be updated. More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
		startupProbe?: {
			exec?: {
				// Command is the command line to execute inside the container,
				// the working directory for the command is root ('/') in the
				// container's filesystem. The command is simply exec'd, it is
				// not run inside a shell, so traditional shell instructions
				// ('|', etc) won't work. To use a shell, you need to explicitly
				// call out to that shell. Exit status of 0 is treated as
				// live/healthy and non-zero is unhealthy.
				command?: [...string]
			}

			// Minimum consecutive failures for the probe to be considered
			// failed after having succeeded. Defaults to 3. Minimum value is
			// 1.
			failureThreshold?: int

			// GRPC specifies an action involving a GRPC port.
			grpc?: {
				// Port number of the gRPC service. Number must be in the range 1
				// to 65535.
				port: int

				// Service is the name of the service to place in the gRPC
				// HealthCheckRequest (see
				// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
				// If this is not specified, the default behavior is defined by
				// gRPC.
				service?: string
			}

			// HTTPGet specifies the http request to perform.
			httpGet?: {
				// Host name to connect to, defaults to the pod IP. You probably
				// want to set "Host" in httpHeaders instead.
				host?: string

				// Custom headers to set in the request. HTTP allows repeated
				// headers.
				httpHeaders?: [...{
					// The header field name. This will be canonicalized upon output,
					// so case-variant names will be understood as the same header.
					name: string

					// The header field value
					value: string
				}]

				// Path to access on the HTTP server.
				path?: string

				// Name or number of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}

				// Scheme to use for connecting to the host. Defaults to HTTP.
				scheme?: string
			}

			// Number of seconds after the container has started before
			// liveness probes are initiated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			initialDelaySeconds?: int

			// How often (in seconds) to perform the probe. Default to 10
			// seconds. Minimum value is 1.
			periodSeconds?: int

			// Minimum consecutive successes for the probe to be considered
			// successful after having failed. Defaults to 1. Must be 1 for
			// liveness and startup. Minimum value is 1.
			successThreshold?: int

			// TCPSocket specifies an action involving a TCP port.
			tcpSocket?: {
				// Optional: Host name to connect to, defaults to the pod IP.
				host?: string

				// Number or name of the port to access on the container. Number
				// must be in the range 1 to 65535. Name must be an
				// IANA_SVC_NAME.
				port: (int | string) & {
					string
				}
			}

			// Optional duration in seconds the pod needs to terminate
			// gracefully upon probe failure. The grace period is the
			// duration in seconds after the processes running in the pod are
			// sent a termination signal and the time when the processes are
			// forcibly halted with a kill signal. Set this value longer than
			// the expected cleanup time for your process. If this value is
			// nil, the pod's terminationGracePeriodSeconds will be used.
			// Otherwise, this value overrides the value provided by the pod
			// spec. Value must be non-negative integer. The value zero
			// indicates stop immediately via the kill signal (no opportunity
			// to shut down). This is a beta field and requires enabling
			// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
			// spec.terminationGracePeriodSeconds is used if unset.
			terminationGracePeriodSeconds?: int

			// Number of seconds after which the probe times out. Defaults to
			// 1 second. Minimum value is 1. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			timeoutSeconds?: int
		}

		// Whether this container should allocate a buffer for stdin in
		// the container runtime. If this is not set, reads from stdin in
		// the container will always result in EOF. Default is false.
		stdin?: bool

		// Whether the container runtime should close the stdin channel
		// after it has been opened by a single attach. When stdin is
		// true the stdin stream will remain open across multiple attach
		// sessions. If stdinOnce is set to true, stdin is opened on
		// container start, is empty until the first client attaches to
		// stdin, and then remains open and accepts data until the client
		// disconnects, at which time stdin is closed and remains closed
		// until the container is restarted. If this flag is false, a
		// container processes that reads from stdin will never receive
		// an EOF. Default is false
		stdinOnce?: bool

		// Optional: Path at which the file to which the container's
		// termination message will be written is mounted into the
		// container's filesystem. Message written is intended to be
		// brief final status, such as an assertion failure message. Will
		// be truncated by the node if greater than 4096 bytes. The total
		// message length across all containers will be limited to 12kb.
		// Defaults to /dev/termination-log. Cannot be updated.
		terminationMessagePath?: string

		// Indicate how the termination message should be populated. File
		// will use the contents of terminationMessagePath to populate
		// the container status message on both success and failure.
		// FallbackToLogsOnError will use the last chunk of container log
		// output if the termination message file is empty and the
		// container exited with an error. The log output is limited to
		// 2048 bytes or 80 lines, whichever is smaller. Defaults to
		// File. Cannot be updated.
		terminationMessagePolicy?: string

		// Whether this container should allocate a TTY for itself, also
		// requires 'stdin' to be true. Default is false.
		tty?: bool

		// volumeDevices is the list of block devices to be used by the
		// container.
		volumeDevices?: [...{
			// devicePath is the path inside of the container that the device
			// will be mapped to.
			devicePath: string

			// name must match the name of a persistentVolumeClaim in the pod
			name: string
		}]

		// Pod volumes to mount into the container's filesystem. Cannot be
		// updated.
		volumeMounts?: [...{
			// Path within the container at which the volume should be
			// mounted. Must not contain ':'.
			mountPath: string

			// mountPropagation determines how mounts are propagated from the
			// host to container and the other way around. When not set,
			// MountPropagationNone is used. This field is beta in 1.10.
			mountPropagation?: string

			// This must match the Name of a Volume.
			name: string

			// Mounted read-only if true, read-write otherwise (false or
			// unspecified). Defaults to false.
			readOnly?: bool

			// Path within the volume from which the container's volume should
			// be mounted. Defaults to "" (volume's root).
			subPath?: string

			// Expanded path within the volume from which the container's
			// volume should be mounted. Behaves similarly to SubPath but
			// environment variable references $(VAR_NAME) are expanded using
			// the container's environment. Defaults to "" (volume's root).
			// SubPathExpr and SubPath are mutually exclusive.
			subPathExpr?: string
		}]

		// Container's working directory. If not specified, the container
		// runtime's default will be used, which might be configured in
		// the container image. Cannot be updated.
		workingDir?: string
	}]

	// Per-scrape limit on the number of targets dropped by relabeling
	// that will be kept in memory. 0 means no limit.
	// It requires Prometheus >= v2.47.0.
	keepDroppedTargets?: int

	// Per-scrape limit on number of labels that will be accepted for
	// a sample. Only valid in Prometheus versions 2.45.0 and newer.
	labelLimit?: int

	// Per-scrape limit on length of labels name that will be accepted
	// for a sample. Only valid in Prometheus versions 2.45.0 and
	// newer.
	labelNameLengthLimit?: int

	// Per-scrape limit on length of labels value that will be
	// accepted for a sample. Only valid in Prometheus versions
	// 2.45.0 and newer.
	labelValueLengthLimit?: int

	// When true, the Prometheus server listens on the loopback
	// address instead of the Pod IP's address.
	listenLocal?: bool

	// Log format for Log level for Prometheus and the config-reloader
	// sidecar.
	logFormat?: "" | "logfmt" | "json"

	// Log level for Prometheus and the config-reloader sidecar.
	logLevel?: "" | "debug" | "info" | "warn" | "error"

	// Defines the maximum time that the `prometheus` container's
	// startup probe will wait before being considered failed. The
	// startup probe will return success after the WAL replay is
	// complete. If set, the value should be greater than 60
	// (seconds). Otherwise it will be equal to 600 seconds (15
	// minutes).
	maximumStartupDurationSeconds?: >=60 & int

	// Minimum number of seconds for which a newly created Pod should
	// be ready without any of its container crashing for it to be
	// considered available. Defaults to 0 (pod will be considered
	// available as soon as it is ready)
	// This is an alpha field from kubernetes 1.22 until 1.24 which
	// requires enabling the StatefulSetMinReadySeconds feature gate.
	minReadySeconds?: int

	// Defines on which Nodes the Pods are scheduled.
	nodeSelector?: {
		[string]: string
	}

	// When true, Prometheus resolves label conflicts by renaming the
	// labels in the scraped data to "exported_<label value>" for all
	// targets created from service and pod monitors. Otherwise the
	// HonorLabels field of the service or pod monitor applies.
	overrideHonorLabels?: bool

	// When true, Prometheus ignores the timestamps for all the
	// targets created from service and pod monitors. Otherwise the
	// HonorTimestamps field of the service or pod monitor applies.
	overrideHonorTimestamps?: bool

	// When a Prometheus deployment is paused, no actions except for
	// deletion will be performed on the underlying objects.
	paused?: bool

	// The field controls if and how PVCs are deleted during the
	// lifecycle of a StatefulSet. The default behavior is all PVCs
	// are retained. This is an alpha field from kubernetes 1.23
	// until 1.26 and a beta field from 1.26. It requires enabling
	// the StatefulSetAutoDeletePVC feature gate.
	persistentVolumeClaimRetentionPolicy?: {
		// WhenDeleted specifies what happens to PVCs created from
		// StatefulSet VolumeClaimTemplates when the StatefulSet is
		// deleted. The default policy of `Retain` causes PVCs to not be
		// affected by StatefulSet deletion. The `Delete` policy causes
		// those PVCs to be deleted.
		whenDeleted?: string

		// WhenScaled specifies what happens to PVCs created from
		// StatefulSet VolumeClaimTemplates when the StatefulSet is
		// scaled down. The default policy of `Retain` causes PVCs to not
		// be affected by a scaledown. The `Delete` policy causes the
		// associated PVCs for any excess pods above the replica count to
		// be deleted.
		whenScaled?: string
	}

	// PodMetadata configures labels and annotations which are
	// propagated to the Prometheus pods.
	// The following items are reserved and cannot be overridden: *
	// "prometheus" label, set to the name of the Prometheus object.
	// * "app.kubernetes.io/instance" label, set to the name of the
	// Prometheus object. * "app.kubernetes.io/managed-by" label, set
	// to "prometheus-operator". * "app.kubernetes.io/name" label,
	// set to "prometheus". * "app.kubernetes.io/version" label, set
	// to the Prometheus version. * "operator.prometheus.io/name"
	// label, set to the name of the Prometheus object. *
	// "operator.prometheus.io/shard" label, set to the shard number
	// of the Prometheus object. *
	// "kubectl.kubernetes.io/default-container" annotation, set to
	// "prometheus".
	podMetadata?: {
		// Annotations is an unstructured key value map stored with a
		// resource that may be set by external tools to store and
		// retrieve arbitrary metadata. They are not queryable and should
		// be preserved when modifying objects. More info:
		// http://kubernetes.io/docs/user-guide/annotations
		annotations?: {
			[string]: string
		}

		// Map of string keys and values that can be used to organize and
		// categorize (scope and select) objects. May match selectors of
		// replication controllers and services. More info:
		// http://kubernetes.io/docs/user-guide/labels
		labels?: {
			[string]: string
		}

		// Name must be unique within a namespace. Is required when
		// creating resources, although some resources may allow a client
		// to request the generation of an appropriate name
		// automatically. Name is primarily intended for creation
		// idempotence and configuration definition. Cannot be updated.
		// More info:
		// http://kubernetes.io/docs/user-guide/identifiers#names
		name?: string
	}

	// Namespaces to match for PodMonitors discovery. An empty label
	// selector matches all namespaces. A null label selector matches
	// the current namespace only.
	podMonitorNamespaceSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// *Experimental* PodMonitors to be selected for target discovery.
	// An empty label selector matches all objects. A null label
	// selector matches no objects.
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`,
	// `spec.probeSelector` and `spec.scrapeConfigSelector` are null,
	// the Prometheus configuration is unmanaged. The Prometheus
	// operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to
	// provide the raw gzipped Prometheus configuration under the
	// `prometheus.yaml.gz` key. This behavior is *deprecated* and
	// will be removed in the next major version of the custom
	// resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	podMonitorSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// PodTargetLabels are appended to the `spec.podTargetLabels`
	// field of all PodMonitor and ServiceMonitor objects.
	podTargetLabels?: [...string]

	// Port name used for the pods and governing service. Default:
	// "web"
	portName?: string | *"web"

	// Priority class assigned to the Pods.
	priorityClassName?: string

	// *Experimental* Namespaces to match for Probe discovery. An
	// empty label selector matches all namespaces. A null label
	// selector matches the current namespace only.
	probeNamespaceSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// *Experimental* Probes to be selected for target discovery. An
	// empty label selector matches all objects. A null label
	// selector matches no objects.
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`,
	// `spec.probeSelector` and `spec.scrapeConfigSelector` are null,
	// the Prometheus configuration is unmanaged. The Prometheus
	// operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to
	// provide the raw gzipped Prometheus configuration under the
	// `prometheus.yaml.gz` key. This behavior is *deprecated* and
	// will be removed in the next major version of the custom
	// resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	probeSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// Name of Prometheus external label used to denote the Prometheus
	// instance name. The external label will _not_ be added when the
	// field is set to the empty string (`""`).
	// Default: "prometheus"
	prometheusExternalLabelName?: string

	// Defines the strategy used to reload the Prometheus
	// configuration. If not specified, the configuration is reloaded
	// using the /-/reload HTTP endpoint.
	reloadStrategy?: "HTTP" | "ProcessSignal"

	// Defines the list of remote write configurations.
	remoteWrite?: [...{
		// Authorization section for the URL.
		// It requires Prometheus >= v2.26.0.
		// Cannot be set at the same time as `sigv4`, `basicAuth`,
		// `oauth2`, or `azureAd`.
		authorization?: {
			// Selects a key of a Secret in the namespace that contains the
			// credentials for authentication.
			credentials?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// File to read a secret from, mutually exclusive with
			// `credentials`.
			credentialsFile?: string

			// Defines the authentication type. The value is case-insensitive.
			// "Basic" is not a supported value.
			// Default: "Bearer"
			type?: string
		}

		// AzureAD for the URL.
		// It requires Prometheus >= v2.45.0.
		// Cannot be set at the same time as `authorization`, `basicAuth`,
		// `oauth2`, or `sigv4`.
		azureAd?: {
			// The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or
			// 'AzureGovernment'.
			cloud?: "AzureChina" | "AzureGovernment" | "AzurePublic"
			managedIdentity?: {
				// The client id
				clientId: string
			}

			// OAuth defines the oauth config that is being used to
			// authenticate. Cannot be set at the same time as
			// `managedIdentity`.
			// It requires Prometheus >= v2.48.0.
			oauth?: {
				// `clientID` is the clientId of the Azure Active Directory
				// application that is being used to authenticate.
				clientId: strings.MinRunes(1)

				// `clientSecret` specifies a key of a Secret containing the
				// client secret of the Azure Active Directory application that
				// is being used to authenticate.
				clientSecret: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}

				// `tenantID` is the tenant ID of the Azure Active Directory
				// application that is being used to authenticate.
				tenantId: strings.MinRunes(1) & {
					=~"^[0-9a-zA-Z-.]+$"
				}
			}
		}

		// BasicAuth configuration for the URL.
		// Cannot be set at the same time as `sigv4`, `authorization`,
		// `oauth2`, or `azureAd`.
		basicAuth?: {
			// `password` specifies a key of a Secret containing the password
			// for authentication.
			password?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// `username` specifies a key of a Secret containing the username
			// for authentication.
			username?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}
		}

		// *Warning: this field shouldn't be used because the token value
		// appears in clear-text. Prefer using `authorization`.*
		// Deprecated: this will be removed in a future release.
		bearerToken?: string

		// File from which to read bearer token for the URL.
		// Deprecated: this will be removed in a future release. Prefer
		// using `authorization`.
		bearerTokenFile?: string

		// Whether to enable HTTP2.
		enableHTTP2?: bool

		// Custom HTTP headers to be sent along with each remote write
		// request. Be aware that headers that are set by Prometheus
		// itself can't be overwritten.
		// It requires Prometheus >= v2.25.0.
		headers?: {
			[string]: string
		}

		// MetadataConfig configures the sending of series metadata to the
		// remote storage.
		metadataConfig?: {
			// Defines whether metric metadata is sent to the remote storage
			// or not.
			send?: bool

			// Defines how frequently metric metadata is sent to the remote
			// storage.
			sendInterval?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
		}

		// The name of the remote write queue, it must be unique if
		// specified. The name is used in metrics and logging in order to
		// differentiate queues.
		// It requires Prometheus >= v2.15.0.
		name?: string

		// OAuth2 configuration for the URL.
		// It requires Prometheus >= v2.27.0.
		// Cannot be set at the same time as `sigv4`, `authorization`,
		// `basicAuth`, or `azureAd`.
		oauth2?: {
			// `clientId` specifies a key of a Secret or ConfigMap containing
			// the OAuth2 client's ID.
			clientId: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// `clientSecret` specifies a key of a Secret containing the
			// OAuth2 client's secret.
			clientSecret: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// `endpointParams` configures the HTTP parameters to append to
			// the token URL.
			endpointParams?: {
				[string]: string
			}

			// `scopes` defines the OAuth2 scopes used for the token request.
			scopes?: [...string]

			// `tokenURL` configures the URL to fetch the token from.
			tokenUrl: strings.MinRunes(1)
		}

		// Optional ProxyURL.
		proxyUrl?: string

		// QueueConfig allows tuning of the remote write queue parameters.
		queueConfig?: {
			// BatchSendDeadline is the maximum time a sample will wait in
			// buffer.
			batchSendDeadline?: string

			// Capacity is the number of samples to buffer per shard before we
			// start dropping them.
			capacity?: int

			// MaxBackoff is the maximum retry delay.
			maxBackoff?: string

			// MaxRetries is the maximum number of times to retry a batch on
			// recoverable errors.
			maxRetries?: int

			// MaxSamplesPerSend is the maximum number of samples per send.
			maxSamplesPerSend?: int

			// MaxShards is the maximum number of shards, i.e. amount of
			// concurrency.
			maxShards?: int

			// MinBackoff is the initial retry delay. Gets doubled for every
			// retry.
			minBackoff?: string

			// MinShards is the minimum number of shards, i.e. amount of
			// concurrency.
			minShards?: int

			// Retry upon receiving a 429 status code from the remote-write
			// storage. This is experimental feature and might change in the
			// future.
			retryOnRateLimit?: bool
		}

		// Timeout for requests to the remote write endpoint.
		remoteTimeout?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"

		// Enables sending of exemplars over remote write. Note that
		// exemplar-storage itself must be enabled using the
		// `spec.enableFeature` option for exemplars to be scraped in the
		// first place.
		// It requires Prometheus >= v2.27.0.
		sendExemplars?: bool

		// Enables sending of native histograms, also known as sparse
		// histograms over remote write.
		// It requires Prometheus >= v2.40.0.
		sendNativeHistograms?: bool

		// Sigv4 allows to configures AWS's Signature Verification 4 for
		// the URL.
		// It requires Prometheus >= v2.26.0.
		// Cannot be set at the same time as `authorization`, `basicAuth`,
		// `oauth2`, or `azureAd`.
		sigv4?: {
			// AccessKey is the AWS API key. If not specified, the environment
			// variable `AWS_ACCESS_KEY_ID` is used.
			accessKey?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Profile is the named AWS profile used to authenticate.
			profile?: string

			// Region is the AWS region. If blank, the region from the default
			// credentials chain used.
			region?: string

			// RoleArn is the named AWS profile used to authenticate.
			roleArn?: string

			// SecretKey is the AWS API secret. If not specified, the
			// environment variable `AWS_SECRET_ACCESS_KEY` is used.
			secretKey?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}
		}

		// TLS Config to use for the URL.
		tlsConfig?: {
			// Certificate authority used when verifying server certificates.
			ca?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the CA cert in the Prometheus container to use for the
			// targets.
			caFile?: string

			// Client certificate to present when doing client-authentication.
			cert?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the client cert file in the Prometheus container for
			// the targets.
			certFile?: string

			// Disable target certificate validation.
			insecureSkipVerify?: bool

			// Path to the client key file in the Prometheus container for the
			// targets.
			keyFile?: string

			// Secret containing the client key file for the targets.
			keySecret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Used to verify the hostname for the targets.
			serverName?: string
		}

		// The URL of the endpoint to send samples to.
		url: string

		// The list of remote write relabel configurations.
		writeRelabelConfigs?: [...{
			// Action to perform based on the regex matching.
			// `Uppercase` and `Lowercase` actions require Prometheus >=
			// v2.36.0. `DropEqual` and `KeepEqual` actions require
			// Prometheus >= v2.41.0.
			// Default: "Replace"
			action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual" | *"replace"

			// Modulus to take of the hash of the source label values.
			// Only applicable when the action is `HashMod`.
			modulus?: int

			// Regular expression against which the extracted value is
			// matched.
			regex?: string

			// Replacement value against which a Replace action is performed
			// if the regular expression matches.
			// Regex capture groups are available.
			replacement?: string

			// Separator is the string between concatenated SourceLabels.
			separator?: string

			// The source labels select values from existing labels. Their
			// content is concatenated using the configured Separator and
			// matched against the configured regular expression.
			sourceLabels?: [...=~"^[a-zA-Z_][a-zA-Z0-9_]*$"]

			// Label to which the resulting string is written in a
			// replacement.
			// It is mandatory for `Replace`, `HashMod`, `Lowercase`,
			// `Uppercase`, `KeepEqual` and `DropEqual` actions.
			// Regex capture groups are available.
			targetLabel?: string
		}]
	}]

	// Name of Prometheus external label used to denote the replica
	// name. The external label will _not_ be added when the field is
	// set to the empty string (`""`).
	// Default: "prometheus_replica"
	replicaExternalLabelName?: string

	// Number of replicas of each shard to deploy for a Prometheus
	// deployment. `spec.replicas` multiplied by `spec.shards` is the
	// total number of Pods created.
	// Default: 1
	replicas?: int

	// Defines the resources requests and limits of the 'prometheus'
	// container.
	resources?: {
		// Claims lists the names of resources, defined in
		// spec.resourceClaims, that are used by this container.
		// This is an alpha field and requires enabling the
		// DynamicResourceAllocation feature gate.
		// This field is immutable. It can only be set for containers.
		claims?: [...{
			// Name must match the name of one entry in
			// pod.spec.resourceClaims of the Pod where this field is used.
			// It makes that resource available inside a container.
			name: string
		}]

		// Limits describes the maximum amount of compute resources
		// allowed. More info:
		// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
		limits?: {
			[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
		}

		// Requests describes the minimum amount of compute resources
		// required. If Requests is omitted for a container, it defaults
		// to Limits if that is explicitly specified, otherwise to an
		// implementation-defined value. Requests cannot exceed Limits.
		// More info:
		// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
		requests?: {
			[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
		}
	}

	// The route prefix Prometheus registers HTTP handlers for.
	// This is useful when using `spec.externalURL`, and a proxy is
	// rewriting HTTP routes of a request, and the actual ExternalURL
	// is still true, but the server serves requests under a
	// different route prefix. For example for use with `kubectl
	// proxy`.
	routePrefix?: string

	// SampleLimit defines per-scrape limit on number of scraped
	// samples that will be accepted. Only valid in Prometheus
	// versions 2.45.0 and newer.
	sampleLimit?: int

	// EXPERIMENTAL List of scrape classes to expose to monitors and
	// other scrape configs. This is experimental feature and might
	// change in the future.
	scrapeClasses?: [...{
		// Default indicates that the scrape applies to all scrape objects
		// that don't configure an explicit scrape class name.
		// Only one scrape class can be set as default.
		default?: bool

		// Name of the scrape class.
		name: strings.MinRunes(1)

		// TLSConfig section for scrapes.
		tlsConfig?: {
			// Certificate authority used when verifying server certificates.
			ca?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the CA cert in the Prometheus container to use for the
			// targets.
			caFile?: string

			// Client certificate to present when doing client-authentication.
			cert?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the client cert file in the Prometheus container for
			// the targets.
			certFile?: string

			// Disable target certificate validation.
			insecureSkipVerify?: bool

			// Path to the client key file in the Prometheus container for the
			// targets.
			keyFile?: string

			// Secret containing the client key file for the targets.
			keySecret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Used to verify the hostname for the targets.
			serverName?: string
		}
	}]

	// Namespaces to match for ScrapeConfig discovery. An empty label
	// selector matches all namespaces. A null label selector matches
	// the current current namespace only.
	scrapeConfigNamespaceSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// *Experimental* ScrapeConfigs to be selected for target
	// discovery. An empty label selector matches all objects. A null
	// label selector matches no objects.
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`,
	// `spec.probeSelector` and `spec.scrapeConfigSelector` are null,
	// the Prometheus configuration is unmanaged. The Prometheus
	// operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to
	// provide the raw gzipped Prometheus configuration under the
	// `prometheus.yaml.gz` key. This behavior is *deprecated* and
	// will be removed in the next major version of the custom
	// resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	scrapeConfigSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// Interval between consecutive scrapes.
	// Default: "30s"
	scrapeInterval?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$" | *"30s"

	// The protocols to negotiate during a scrape. It tells clients
	// the protocols supported by Prometheus in order of preference
	// (from most to least preferred).
	// If unset, Prometheus uses its default value.
	// It requires Prometheus >= v2.49.0.
	scrapeProtocols?: [..."PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4"]

	// Number of seconds to wait until a scrape request times out.
	scrapeTimeout?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"

	// Secrets is a list of Secrets in the same namespace as the
	// Prometheus object, which shall be mounted into the Prometheus
	// Pods. Each Secret is added to the StatefulSet definition as a
	// volume named `secret-<secret-name>`. The Secrets are mounted
	// into /etc/prometheus/secrets/<secret-name> in the 'prometheus'
	// container.
	secrets?: [...string]

	// SecurityContext holds pod-level security attributes and common
	// container settings. This defaults to the default
	// PodSecurityContext.
	securityContext?: {
		// A special supplemental group that applies to all containers in
		// a pod. Some volume types allow the Kubelet to change the
		// ownership of that volume to be owned by the pod:
		// 1. The owning GID will be the FSGroup 2. The setgid bit is set
		// (new files created in the volume will be owned by FSGroup) 3.
		// The permission bits are OR'd with rw-rw----
		// If unset, the Kubelet will not modify the ownership and
		// permissions of any volume. Note that this field cannot be set
		// when spec.os.name is windows.
		fsGroup?: int

		// fsGroupChangePolicy defines behavior of changing ownership and
		// permission of the volume before being exposed inside Pod. This
		// field will only apply to volume types which support fsGroup
		// based ownership(and permissions). It will have no effect on
		// ephemeral volume types such as: secret, configmaps and
		// emptydir. Valid values are "OnRootMismatch" and "Always". If
		// not specified, "Always" is used. Note that this field cannot
		// be set when spec.os.name is windows.
		fsGroupChangePolicy?: string

		// The GID to run the entrypoint of the container process. Uses
		// runtime default if unset. May also be set in SecurityContext.
		// If set in both SecurityContext and PodSecurityContext, the
		// value specified in SecurityContext takes precedence for that
		// container. Note that this field cannot be set when
		// spec.os.name is windows.
		runAsGroup?: int

		// Indicates that the container must run as a non-root user. If
		// true, the Kubelet will validate the image at runtime to ensure
		// that it does not run as UID 0 (root) and fail to start the
		// container if it does. If unset or false, no such validation
		// will be performed. May also be set in SecurityContext. If set
		// in both SecurityContext and PodSecurityContext, the value
		// specified in SecurityContext takes precedence.
		runAsNonRoot?: bool

		// The UID to run the entrypoint of the container process.
		// Defaults to user specified in image metadata if unspecified.
		// May also be set in SecurityContext. If set in both
		// SecurityContext and PodSecurityContext, the value specified in
		// SecurityContext takes precedence for that container. Note that
		// this field cannot be set when spec.os.name is windows.
		runAsUser?: int

		// The SELinux context to be applied to all containers. If
		// unspecified, the container runtime will allocate a random
		// SELinux context for each container. May also be set in
		// SecurityContext. If set in both SecurityContext and
		// PodSecurityContext, the value specified in SecurityContext
		// takes precedence for that container. Note that this field
		// cannot be set when spec.os.name is windows.
		seLinuxOptions?: {
			// Level is SELinux level label that applies to the container.
			level?: string

			// Role is a SELinux role label that applies to the container.
			role?: string

			// Type is a SELinux type label that applies to the container.
			type?: string

			// User is a SELinux user label that applies to the container.
			user?: string
		}

		// The seccomp options to use by the containers in this pod. Note
		// that this field cannot be set when spec.os.name is windows.
		seccompProfile?: {
			// localhostProfile indicates a profile defined in a file on the
			// node should be used. The profile must be preconfigured on the
			// node to work. Must be a descending path, relative to the
			// kubelet's configured seccomp profile location. Must be set if
			// type is "Localhost". Must NOT be set for any other type.
			localhostProfile?: string

			// type indicates which kind of seccomp profile will be applied.
			// Valid options are:
			// Localhost - a profile defined in a file on the node should be
			// used. RuntimeDefault - the container runtime default profile
			// should be used. Unconfined - no profile should be applied.
			type: string
		}

		// A list of groups applied to the first process run in each
		// container, in addition to the container's primary GID, the
		// fsGroup (if specified), and group memberships defined in the
		// container image for the uid of the container process. If
		// unspecified, no additional groups are added to any container.
		// Note that group memberships defined in the container image for
		// the uid of the container process are still effective, even if
		// they are not included in this list. Note that this field
		// cannot be set when spec.os.name is windows.
		supplementalGroups?: [...int]

		// Sysctls hold a list of namespaced sysctls used for the pod.
		// Pods with unsupported sysctls (by the container runtime) might
		// fail to launch. Note that this field cannot be set when
		// spec.os.name is windows.
		sysctls?: [...{
			// Name of a property to set
			name: string

			// Value of a property to set
			value: string
		}]

		// The Windows specific settings applied to all containers. If
		// unspecified, the options within a container's SecurityContext
		// will be used. If set in both SecurityContext and
		// PodSecurityContext, the value specified in SecurityContext
		// takes precedence. Note that this field cannot be set when
		// spec.os.name is linux.
		windowsOptions?: {
			// GMSACredentialSpec is where the GMSA admission webhook
			// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
			// contents of the GMSA credential spec named by the
			// GMSACredentialSpecName field.
			gmsaCredentialSpec?: string

			// GMSACredentialSpecName is the name of the GMSA credential spec
			// to use.
			gmsaCredentialSpecName?: string

			// HostProcess determines if a container should be run as a 'Host
			// Process' container. All of a Pod's containers must have the
			// same effective HostProcess value (it is not allowed to have a
			// mix of HostProcess containers and non-HostProcess containers).
			// In addition, if HostProcess is true then HostNetwork must also
			// be set to true.
			hostProcess?: bool

			// The UserName in Windows to run the entrypoint of the container
			// process. Defaults to the user specified in image metadata if
			// unspecified. May also be set in PodSecurityContext. If set in
			// both SecurityContext and PodSecurityContext, the value
			// specified in SecurityContext takes precedence.
			runAsUserName?: string
		}
	}

	// ServiceAccountName is the name of the ServiceAccount to use to
	// run the Prometheus Pods.
	serviceAccountName?: string

	// Namespaces to match for ServicedMonitors discovery. An empty
	// label selector matches all namespaces. A null label selector
	// matches the current namespace only.
	serviceMonitorNamespaceSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// ServiceMonitors to be selected for target discovery. An empty
	// label selector matches all objects. A null label selector
	// matches no objects.
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`,
	// `spec.probeSelector` and `spec.scrapeConfigSelector` are null,
	// the Prometheus configuration is unmanaged. The Prometheus
	// operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to
	// provide the raw gzipped Prometheus configuration under the
	// `prometheus.yaml.gz` key. This behavior is *deprecated* and
	// will be removed in the next major version of the custom
	// resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	serviceMonitorSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn, the values array must be non-empty. If the operator is
			// Exists or DoesNotExist, the values array must be empty. This
			// array is replaced during a strategic merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels map is equivalent to an element of
		// matchExpressions, whose key field is "key", the operator is
		// "In", and the values array contains only "value". The
		// requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// EXPERIMENTAL: Number of shards to distribute targets onto.
	// `spec.replicas` multiplied by `spec.shards` is the total
	// number of Pods created.
	// Note that scaling down shards will not reshard data onto
	// remaining instances, it must be manually moved. Increasing
	// shards will not reshard data either but it will continue to be
	// available from the same instances. To query globally, use
	// Thanos sidecar and Thanos querier or remote write data to a
	// central location.
	// Sharding is performed on the content of the `__address__`
	// target meta-label for PodMonitors and ServiceMonitors and
	// `__param_target__` for Probes.
	// Default: 1
	shards?: int

	// Storage defines the storage used by Prometheus.
	storage?: {
		// Deprecated: subPath usage will be removed in a future release.
		disableMountSubPath?: bool

		// EmptyDirVolumeSource to be used by the StatefulSet. If
		// specified, it takes precedence over `ephemeral` and
		// `volumeClaimTemplate`. More info:
		// https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
		emptyDir?: {
			// medium represents what type of storage medium should back this
			// directory. The default is "" which means to use the node's
			// default medium. Must be an empty string (default) or Memory.
			// More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
			medium?: string

			// sizeLimit is the total amount of local storage required for
			// this EmptyDir volume. The size limit is also applicable for
			// memory medium. The maximum usage on memory medium EmptyDir
			// would be the minimum value between the SizeLimit specified
			// here and the sum of memory limits of all containers in a pod.
			// The default is nil which means that the limit is undefined.
			// More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
			sizeLimit?: (int | string) & {
				=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}
		}
		ephemeral?: {
			// Will be used to create a stand-alone PVC to provision the
			// volume. The pod in which this EphemeralVolumeSource is
			// embedded will be the owner of the PVC, i.e. the PVC will be
			// deleted together with the pod. The name of the PVC will be
			// `<pod name>-<volume name>` where `<volume name>` is the name
			// from the `PodSpec.Volumes` array entry. Pod validation will
			// reject the pod if the concatenated name is not valid for a PVC
			// (for example, too long).
			// An existing PVC with that name that is not owned by the pod
			// will *not* be used for the pod to avoid using an unrelated
			// volume by mistake. Starting the pod is then blocked until the
			// unrelated PVC is removed. If such a pre-created PVC is meant
			// to be used by the pod, the PVC has to updated with an owner
			// reference to the pod once the pod exists. Normally this should
			// not be necessary, but it may be useful when manually
			// reconstructing a broken cluster.
			// This field is read-only and no changes will be made by
			// Kubernetes to the PVC after it has been created.
			// Required, must not be nil.
			volumeClaimTemplate?: {
				// May contain labels and annotations that will be copied into the
				// PVC when creating it. No other fields are allowed and will be
				// rejected during validation.
				metadata?: {}

				// The specification for the PersistentVolumeClaim. The entire
				// content is copied unchanged into the PVC that gets created
				// from this template. The same fields as in a
				// PersistentVolumeClaim are also valid here.
				spec: {
					// accessModes contains the desired access modes the volume should
					// have. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
					accessModes?: [...string]

					// dataSource field can be used to specify either: * An existing
					// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
					// * An existing PVC (PersistentVolumeClaim) If the provisioner
					// or an external controller can support the specified data
					// source, it will create a new volume based on the contents of
					// the specified data source. When the AnyVolumeDataSource
					// feature gate is enabled, dataSource contents will be copied to
					// dataSourceRef, and dataSourceRef contents will be copied to
					// dataSource when dataSourceRef.namespace is not specified. If
					// the namespace is specified, then dataSourceRef will not be
					// copied to dataSource.
					dataSource?: {
						// APIGroup is the group for the resource being referenced. If
						// APIGroup is not specified, the specified Kind must be in the
						// core API group. For any other third-party types, APIGroup is
						// required.
						apiGroup?: string

						// Kind is the type of resource being referenced
						kind: string

						// Name is the name of resource being referenced
						name: string
					}

					// dataSourceRef specifies the object from which to populate the
					// volume with data, if a non-empty volume is desired. This may
					// be any object from a non-empty API group (non core object) or
					// a PersistentVolumeClaim object. When this field is specified,
					// volume binding will only succeed if the type of the specified
					// object matches some installed volume populator or dynamic
					// provisioner. This field will replace the functionality of the
					// dataSource field and as such if both fields are non-empty,
					// they must have the same value. For backwards compatibility,
					// when namespace isn't specified in dataSourceRef, both fields
					// (dataSource and dataSourceRef) will be set to the same value
					// automatically if one of them is empty and the other is
					// non-empty. When namespace is specified in dataSourceRef,
					// dataSource isn't set to the same value and must be empty.
					// There are three important differences between dataSource and
					// dataSourceRef: * While dataSource only allows two specific
					// types of objects, dataSourceRef allows any non-core object, as
					// well as PersistentVolumeClaim objects. * While dataSource
					// ignores disallowed values (dropping them), dataSourceRef
					// preserves all values, and generates an error if a disallowed
					// value is specified. * While dataSource only allows local
					// objects, dataSourceRef allows objects in any namespaces.
					// (Beta) Using this field requires the AnyVolumeDataSource
					// feature gate to be enabled. (Alpha) Using the namespace field
					// of dataSourceRef requires the CrossNamespaceVolumeDataSource
					// feature gate to be enabled.
					dataSourceRef?: {
						// APIGroup is the group for the resource being referenced. If
						// APIGroup is not specified, the specified Kind must be in the
						// core API group. For any other third-party types, APIGroup is
						// required.
						apiGroup?: string

						// Kind is the type of resource being referenced
						kind: string

						// Name is the name of resource being referenced
						name: string

						// Namespace is the namespace of resource being referenced Note
						// that when a namespace is specified, a
						// gateway.networking.k8s.io/ReferenceGrant object is required in
						// the referent namespace to allow that namespace's owner to
						// accept the reference. See the ReferenceGrant documentation for
						// details. (Alpha) This field requires the
						// CrossNamespaceVolumeDataSource feature gate to be enabled.
						namespace?: string
					}

					// resources represents the minimum resources the volume should
					// have. If RecoverVolumeExpansionFailure feature is enabled
					// users are allowed to specify resource requirements that are
					// lower than previous value but must still be higher than
					// capacity recorded in the status field of the claim. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
					resources?: {
						// Limits describes the maximum amount of compute resources
						// allowed. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						limits?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Requests describes the minimum amount of compute resources
						// required. If Requests is omitted for a container, it defaults
						// to Limits if that is explicitly specified, otherwise to an
						// implementation-defined value. Requests cannot exceed Limits.
						// More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						requests?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}
					}

					// selector is a label query over volumes to consider for binding.
					selector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// storageClassName is the name of the StorageClass required by
					// the claim. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
					storageClassName?: string

					// volumeAttributesClassName may be used to set the
					// VolumeAttributesClass used by this claim. If specified, the
					// CSI driver will create or update the volume with the
					// attributes defined in the corresponding VolumeAttributesClass.
					// This has a different purpose than storageClassName, it can be
					// changed after the claim is created. An empty string value
					// means that no VolumeAttributesClass will be applied to the
					// claim but it's not allowed to reset this field to empty string
					// once it is set. If unspecified and the PersistentVolumeClaim
					// is unbound, the default VolumeAttributesClass will be set by
					// the persistentvolume controller if it exists. If the resource
					// referred to by volumeAttributesClass does not exist, this
					// PersistentVolumeClaim will be set to a Pending state, as
					// reflected by the modifyVolumeStatus field, until such as a
					// resource exists. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
					// (Alpha) Using this field requires the VolumeAttributesClass
					// feature gate to be enabled.
					volumeAttributesClassName?: string

					// volumeMode defines what type of volume is required by the
					// claim. Value of Filesystem is implied when not included in
					// claim spec.
					volumeMode?: string

					// volumeName is the binding reference to the PersistentVolume
					// backing this claim.
					volumeName?: string
				}
			}
		}

		// Defines the PVC spec to be used by the Prometheus StatefulSets.
		// The easiest way to use a volume that cannot be automatically
		// provisioned is to use a label selector alongside manually
		// created PersistentVolumes.
		volumeClaimTemplate?: {
			// APIVersion defines the versioned schema of this representation
			// of an object. Servers should convert recognized schemas to the
			// latest internal value, and may reject unrecognized values.
			// More info:
			// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			apiVersion?: string

			// Kind is a string value representing the REST resource this
			// object represents. Servers may infer this from the endpoint
			// the client submits requests to. Cannot be updated. In
			// CamelCase. More info:
			// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			kind?: string

			// EmbeddedMetadata contains metadata relevant to an
			// EmbeddedResource.
			metadata?: {
				// Annotations is an unstructured key value map stored with a
				// resource that may be set by external tools to store and
				// retrieve arbitrary metadata. They are not queryable and should
				// be preserved when modifying objects. More info:
				// http://kubernetes.io/docs/user-guide/annotations
				annotations?: {
					[string]: string
				}

				// Map of string keys and values that can be used to organize and
				// categorize (scope and select) objects. May match selectors of
				// replication controllers and services. More info:
				// http://kubernetes.io/docs/user-guide/labels
				labels?: {
					[string]: string
				}

				// Name must be unique within a namespace. Is required when
				// creating resources, although some resources may allow a client
				// to request the generation of an appropriate name
				// automatically. Name is primarily intended for creation
				// idempotence and configuration definition. Cannot be updated.
				// More info:
				// http://kubernetes.io/docs/user-guide/identifiers#names
				name?: string
			}

			// Defines the desired characteristics of a volume requested by a
			// pod author. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
			spec?: {
				// accessModes contains the desired access modes the volume should
				// have. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
				accessModes?: [...string]

				// dataSource field can be used to specify either: * An existing
				// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
				// * An existing PVC (PersistentVolumeClaim) If the provisioner
				// or an external controller can support the specified data
				// source, it will create a new volume based on the contents of
				// the specified data source. When the AnyVolumeDataSource
				// feature gate is enabled, dataSource contents will be copied to
				// dataSourceRef, and dataSourceRef contents will be copied to
				// dataSource when dataSourceRef.namespace is not specified. If
				// the namespace is specified, then dataSourceRef will not be
				// copied to dataSource.
				dataSource?: {
					// APIGroup is the group for the resource being referenced. If
					// APIGroup is not specified, the specified Kind must be in the
					// core API group. For any other third-party types, APIGroup is
					// required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string
				}

				// dataSourceRef specifies the object from which to populate the
				// volume with data, if a non-empty volume is desired. This may
				// be any object from a non-empty API group (non core object) or
				// a PersistentVolumeClaim object. When this field is specified,
				// volume binding will only succeed if the type of the specified
				// object matches some installed volume populator or dynamic
				// provisioner. This field will replace the functionality of the
				// dataSource field and as such if both fields are non-empty,
				// they must have the same value. For backwards compatibility,
				// when namespace isn't specified in dataSourceRef, both fields
				// (dataSource and dataSourceRef) will be set to the same value
				// automatically if one of them is empty and the other is
				// non-empty. When namespace is specified in dataSourceRef,
				// dataSource isn't set to the same value and must be empty.
				// There are three important differences between dataSource and
				// dataSourceRef: * While dataSource only allows two specific
				// types of objects, dataSourceRef allows any non-core object, as
				// well as PersistentVolumeClaim objects. * While dataSource
				// ignores disallowed values (dropping them), dataSourceRef
				// preserves all values, and generates an error if a disallowed
				// value is specified. * While dataSource only allows local
				// objects, dataSourceRef allows objects in any namespaces.
				// (Beta) Using this field requires the AnyVolumeDataSource
				// feature gate to be enabled. (Alpha) Using the namespace field
				// of dataSourceRef requires the CrossNamespaceVolumeDataSource
				// feature gate to be enabled.
				dataSourceRef?: {
					// APIGroup is the group for the resource being referenced. If
					// APIGroup is not specified, the specified Kind must be in the
					// core API group. For any other third-party types, APIGroup is
					// required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string

					// Namespace is the namespace of resource being referenced Note
					// that when a namespace is specified, a
					// gateway.networking.k8s.io/ReferenceGrant object is required in
					// the referent namespace to allow that namespace's owner to
					// accept the reference. See the ReferenceGrant documentation for
					// details. (Alpha) This field requires the
					// CrossNamespaceVolumeDataSource feature gate to be enabled.
					namespace?: string
				}

				// resources represents the minimum resources the volume should
				// have. If RecoverVolumeExpansionFailure feature is enabled
				// users are allowed to specify resource requirements that are
				// lower than previous value but must still be higher than
				// capacity recorded in the status field of the claim. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. Requests cannot exceed Limits.
					// More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// selector is a label query over volumes to consider for binding.
				selector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// storageClassName is the name of the StorageClass required by
				// the claim. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
				storageClassName?: string

				// volumeAttributesClassName may be used to set the
				// VolumeAttributesClass used by this claim. If specified, the
				// CSI driver will create or update the volume with the
				// attributes defined in the corresponding VolumeAttributesClass.
				// This has a different purpose than storageClassName, it can be
				// changed after the claim is created. An empty string value
				// means that no VolumeAttributesClass will be applied to the
				// claim but it's not allowed to reset this field to empty string
				// once it is set. If unspecified and the PersistentVolumeClaim
				// is unbound, the default VolumeAttributesClass will be set by
				// the persistentvolume controller if it exists. If the resource
				// referred to by volumeAttributesClass does not exist, this
				// PersistentVolumeClaim will be set to a Pending state, as
				// reflected by the modifyVolumeStatus field, until such as a
				// resource exists. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
				// (Alpha) Using this field requires the VolumeAttributesClass
				// feature gate to be enabled.
				volumeAttributesClassName?: string

				// volumeMode defines what type of volume is required by the
				// claim. Value of Filesystem is implied when not included in
				// claim spec.
				volumeMode?: string

				// volumeName is the binding reference to the PersistentVolume
				// backing this claim.
				volumeName?: string
			}

			// Deprecated: this field is never set.
			status?: {
				// accessModes contains the actual access modes the volume backing
				// the PVC has. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
				accessModes?: [...string]

				// allocatedResourceStatuses stores status of resource being
				// resized for the given PVC. Key names follow standard
				// Kubernetes label syntax. Valid values are either: *
				// Un-prefixed keys: - storage - the capacity of the volume. *
				// Custom resources must use implementation-defined prefixed
				// names such as "example.com/my-custom-resource" Apart from
				// above values - keys that are unprefixed or have kubernetes.io
				// prefix are considered reserved and hence may not be used.
				// ClaimResourceStatus can be in any of following states: -
				// ControllerResizeInProgress: State set when resize controller
				// starts resizing the volume in control-plane. -
				// ControllerResizeFailed: State set when resize has failed in
				// resize controller with a terminal error. - NodeResizePending:
				// State set when resize controller has finished resizing the
				// volume but further resizing of volume is needed on the node. -
				// NodeResizeInProgress: State set when kubelet starts resizing
				// the volume. - NodeResizeFailed: State set when resizing has
				// failed in kubelet with a terminal error. Transient errors
				// don't set NodeResizeFailed. For example: if expanding a PVC
				// for more capacity - this field can be one of the following
				// states: - pvc.status.allocatedResourceStatus['storage'] =
				// "ControllerResizeInProgress" -
				// pvc.status.allocatedResourceStatus['storage'] =
				// "ControllerResizeFailed" -
				// pvc.status.allocatedResourceStatus['storage'] =
				// "NodeResizePending" -
				// pvc.status.allocatedResourceStatus['storage'] =
				// "NodeResizeInProgress" -
				// pvc.status.allocatedResourceStatus['storage'] =
				// "NodeResizeFailed" When this field is not set, it means that
				// no resize operation is in progress for the given PVC.
				// A controller that receives PVC update with previously unknown
				// resourceName or ClaimResourceStatus should ignore the update
				// for the purpose it was designed. For example - a controller
				// that only is responsible for resizing capacity of the volume,
				// should ignore PVC updates that change other valid resources
				// associated with PVC.
				// This is an alpha field and requires enabling
				// RecoverVolumeExpansionFailure feature.
				allocatedResourceStatuses?: {
					[string]: string
				}

				// allocatedResources tracks the resources allocated to a PVC
				// including its capacity. Key names follow standard Kubernetes
				// label syntax. Valid values are either: * Un-prefixed keys: -
				// storage - the capacity of the volume. * Custom resources must
				// use implementation-defined prefixed names such as
				// "example.com/my-custom-resource" Apart from above values -
				// keys that are unprefixed or have kubernetes.io prefix are
				// considered reserved and hence may not be used.
				// Capacity reported here may be larger than the actual capacity
				// when a volume expansion operation is requested. For storage
				// quota, the larger value from allocatedResources and
				// PVC.spec.resources is used. If allocatedResources is not set,
				// PVC.spec.resources alone is used for quota calculation. If a
				// volume expansion capacity request is lowered,
				// allocatedResources is only lowered if there are no expansion
				// operations in progress and if the actual volume capacity is
				// equal or lower than the requested capacity.
				// A controller that receives PVC update with previously unknown
				// resourceName should ignore the update for the purpose it was
				// designed. For example - a controller that only is responsible
				// for resizing capacity of the volume, should ignore PVC updates
				// that change other valid resources associated with PVC.
				// This is an alpha field and requires enabling
				// RecoverVolumeExpansionFailure feature.
				allocatedResources?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// capacity represents the actual resources of the underlying
				// volume.
				capacity?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// conditions is the current Condition of persistent volume claim.
				// If underlying persistent volume is being resized then the
				// Condition will be set to 'ResizeStarted'.
				conditions?: [...{
					// lastProbeTime is the time we probed the condition.
					lastProbeTime?: string

					// lastTransitionTime is the time the condition transitioned from
					// one status to another.
					lastTransitionTime?: string

					// message is the human-readable message indicating details about
					// last transition.
					message?: string

					// reason is a unique, this should be a short, machine
					// understandable string that gives the reason for condition's
					// last transition. If it reports "ResizeStarted" that means the
					// underlying persistent volume is being resized.
					reason?: string
					status:  string

					// PersistentVolumeClaimConditionType is a valid value of
					// PersistentVolumeClaimCondition.Type
					type: string
				}]

				// currentVolumeAttributesClassName is the current name of the
				// VolumeAttributesClass the PVC is using. When unset, there is
				// no VolumeAttributeClass applied to this PersistentVolumeClaim
				// This is an alpha field and requires enabling
				// VolumeAttributesClass feature.
				currentVolumeAttributesClassName?: string

				// ModifyVolumeStatus represents the status object of
				// ControllerModifyVolume operation. When this is unset, there is
				// no ModifyVolume operation being attempted. This is an alpha
				// field and requires enabling VolumeAttributesClass feature.
				modifyVolumeStatus?: {
					// status is the status of the ControllerModifyVolume operation.
					// It can be in any of following states: - Pending Pending
					// indicates that the PersistentVolumeClaim cannot be modified
					// due to unmet requirements, such as the specified
					// VolumeAttributesClass not existing. - InProgress InProgress
					// indicates that the volume is being modified. - Infeasible
					// Infeasible indicates that the request has been rejected as
					// invalid by the CSI driver. To resolve the error, a valid
					// VolumeAttributesClass needs to be specified. Note: New
					// statuses can be added in the future. Consumers should check
					// for unknown statuses and fail appropriately.
					status: string

					// targetVolumeAttributesClassName is the name of the
					// VolumeAttributesClass the PVC currently being reconciled
					targetVolumeAttributesClassName?: string
				}

				// phase represents the current phase of PersistentVolumeClaim.
				phase?: string
			}
		}
	}

	// TargetLimit defines a limit on the number of scraped targets
	// that will be accepted. Only valid in Prometheus versions
	// 2.45.0 and newer.
	targetLimit?: int

	// Defines the Pods' tolerations if specified.
	tolerations?: [...{
		// Effect indicates the taint effect to match. Empty means match
		// all taint effects. When specified, allowed values are
		// NoSchedule, PreferNoSchedule and NoExecute.
		effect?: string

		// Key is the taint key that the toleration applies to. Empty
		// means match all taint keys. If the key is empty, operator must
		// be Exists; this combination means to match all values and all
		// keys.
		key?: string

		// Operator represents a key's relationship to the value. Valid
		// operators are Exists and Equal. Defaults to Equal. Exists is
		// equivalent to wildcard for value, so that a pod can tolerate
		// all taints of a particular category.
		operator?: string

		// TolerationSeconds represents the period of time the toleration
		// (which must be of effect NoExecute, otherwise this field is
		// ignored) tolerates the taint. By default, it is not set, which
		// means tolerate the taint forever (do not evict). Zero and
		// negative values will be treated as 0 (evict immediately) by
		// the system.
		tolerationSeconds?: int

		// Value is the taint value the toleration matches to. If the
		// operator is Exists, the value should be empty, otherwise just
		// a regular string.
		value?: string
	}]

	// Defines the pod's topology spread constraints if specified.
	topologySpreadConstraints?: [...{
		// Defines what Prometheus Operator managed labels should be added
		// to labelSelector on the topologySpreadConstraint.
		additionalLabelSelectors?: "OnResource" | "OnShard"

		// LabelSelector is used to find matching pods. Pods that match
		// this label selector are counted to determine the number of
		// pods in their corresponding topology domain.
		labelSelector?: {
			// matchExpressions is a list of label selector requirements. The
			// requirements are ANDed.
			matchExpressions?: [...{
				// key is the label key that the selector applies to.
				key: string

				// operator represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists and DoesNotExist.
				operator: string

				// values is an array of string values. If the operator is In or
				// NotIn, the values array must be non-empty. If the operator is
				// Exists or DoesNotExist, the values array must be empty. This
				// array is replaced during a strategic merge patch.
				values?: [...string]
			}]

			// matchLabels is a map of {key,value} pairs. A single {key,value}
			// in the matchLabels map is equivalent to an element of
			// matchExpressions, whose key field is "key", the operator is
			// "In", and the values array contains only "value". The
			// requirements are ANDed.
			matchLabels?: {
				[string]: string
			}
		}

		// MatchLabelKeys is a set of pod label keys to select the pods
		// over which spreading will be calculated. The keys are used to
		// lookup values from the incoming pod labels, those key-value
		// labels are ANDed with labelSelector to select the group of
		// existing pods over which spreading will be calculated for the
		// incoming pod. The same key is forbidden to exist in both
		// MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set
		// when LabelSelector isn't set. Keys that don't exist in the
		// incoming pod labels will be ignored. A null or empty list
		// means only match against labelSelector.
		// This is a beta field and requires the
		// MatchLabelKeysInPodTopologySpread feature gate to be enabled
		// (enabled by default).
		matchLabelKeys?: [...string]

		// MaxSkew describes the degree to which pods may be unevenly
		// distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the
		// maximum permitted difference between the number of matching
		// pods in the target topology and the global minimum. The global
		// minimum is the minimum number of matching pods in an eligible
		// domain or zero if the number of eligible domains is less than
		// MinDomains. For example, in a 3-zone cluster, MaxSkew is set
		// to 1, and pods with the same labelSelector spread as 2/2/1: In
		// this case, the global minimum is 1. | zone1 | zone2 | zone3 |
		// | P P | P P | P | - if MaxSkew is 1, incoming pod can only be
		// scheduled to zone3 to become 2/2/2; scheduling it onto
		// zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
		// violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be
		// scheduled onto any zone. When
		// `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher
		// precedence to topologies that satisfy it. It's a required
		// field. Default value is 1 and 0 is not allowed.
		maxSkew: int

		// MinDomains indicates a minimum number of eligible domains. When
		// the number of eligible domains with matching topology keys is
		// less than minDomains, Pod Topology Spread treats "global
		// minimum" as 0, and then the calculation of Skew is performed.
		// And when the number of eligible domains with matching topology
		// keys equals or greater than minDomains, this value has no
		// effect on scheduling. As a result, when the number of eligible
		// domains is less than minDomains, scheduler won't schedule more
		// than maxSkew Pods to those domains. If value is nil, the
		// constraint behaves as if MinDomains is equal to 1. Valid
		// values are integers greater than 0. When value is not nil,
		// WhenUnsatisfiable must be DoNotSchedule.
		// For example, in a 3-zone cluster, MaxSkew is set to 2,
		// MinDomains is set to 5 and pods with the same labelSelector
		// spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P |
		// The number of domains is less than 5(MinDomains), so "global
		// minimum" is treated as 0. In this situation, new pod with the
		// same labelSelector cannot be scheduled, because computed skew
		// will be 3(3 - 0) if new Pod is scheduled to any of the three
		// zones, it will violate MaxSkew.
		// This is a beta field and requires the
		// MinDomainsInPodTopologySpread feature gate to be enabled
		// (enabled by default).
		minDomains?: int

		// NodeAffinityPolicy indicates how we will treat Pod's
		// nodeAffinity/nodeSelector when calculating pod topology spread
		// skew. Options are: - Honor: only nodes matching
		// nodeAffinity/nodeSelector are included in the calculations. -
		// Ignore: nodeAffinity/nodeSelector are ignored. All nodes are
		// included in the calculations.
		// If this value is nil, the behavior is equivalent to the Honor
		// policy. This is a beta-level feature default enabled by the
		// NodeInclusionPolicyInPodTopologySpread feature flag.
		nodeAffinityPolicy?: string

		// NodeTaintsPolicy indicates how we will treat node taints when
		// calculating pod topology spread skew. Options are: - Honor:
		// nodes without taints, along with tainted nodes for which the
		// incoming pod has a toleration, are included. - Ignore: node
		// taints are ignored. All nodes are included.
		// If this value is nil, the behavior is equivalent to the Ignore
		// policy. This is a beta-level feature default enabled by the
		// NodeInclusionPolicyInPodTopologySpread feature flag.
		nodeTaintsPolicy?: string

		// TopologyKey is the key of node labels. Nodes that have a label
		// with this key and identical values are considered to be in the
		// same topology. We consider each <key, value> as a "bucket",
		// and try to put balanced number of pods into each bucket. We
		// define a domain as a particular instance of a topology. Also,
		// we define an eligible domain as a domain whose nodes meet the
		// requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g.
		// If TopologyKey is "kubernetes.io/hostname", each Node is a
		// domain of that topology. And, if TopologyKey is
		// "topology.kubernetes.io/zone", each zone is a domain of that
		// topology. It's a required field.
		topologyKey: string

		// WhenUnsatisfiable indicates how to deal with a pod if it
		// doesn't satisfy the spread constraint. - DoNotSchedule
		// (default) tells the scheduler not to schedule it. -
		// ScheduleAnyway tells the scheduler to schedule the pod in any
		// location, but giving higher precedence to topologies that
		// would help reduce the skew. A constraint is considered
		// "Unsatisfiable" for an incoming pod if and only if every
		// possible node assignment for that pod would violate "MaxSkew"
		// on some topology. For example, in a 3-zone cluster, MaxSkew is
		// set to 1, and pods with the same labelSelector spread as
		// 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If
		// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can
		// only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as
		// ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other
		// words, the cluster can still be imbalanced, but scheduler
		// won't make it *more* imbalanced. It's a required field.
		whenUnsatisfiable: string
	}]

	// EXPERIMENTAL: TracingConfig configures tracing in Prometheus.
	// This is an experimental feature, it may change in any upcoming
	// release in a breaking way.
	tracingConfig?: {
		// Client used to export the traces. Supported values are `http`
		// or `grpc`.
		clientType?: "http" | "grpc"

		// Compression key for supported compression types. The only
		// supported value is `gzip`.
		compression?: "gzip"

		// Endpoint to send the traces to. Should be provided in format
		// <host>:<port>.
		endpoint: strings.MinRunes(1)

		// Key-value pairs to be used as headers associated with gRPC or
		// HTTP requests.
		headers?: {
			[string]: string
		}

		// If disabled, the client will use a secure connection.
		insecure?: bool

		// Sets the probability a given trace will be sampled. Must be a
		// float from 0 through 1.
		samplingFraction?: (int | string) & {
			=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
		}

		// Maximum time the exporter will wait for each batch export.
		timeout?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"

		// TLS Config to use when sending traces.
		tlsConfig?: {
			// Certificate authority used when verifying server certificates.
			ca?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the CA cert in the Prometheus container to use for the
			// targets.
			caFile?: string

			// Client certificate to present when doing client-authentication.
			cert?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the client cert file in the Prometheus container for
			// the targets.
			certFile?: string

			// Disable target certificate validation.
			insecureSkipVerify?: bool

			// Path to the client key file in the Prometheus container for the
			// targets.
			keyFile?: string

			// Secret containing the client key file for the targets.
			keySecret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Used to verify the hostname for the targets.
			serverName?: string
		}
	}

	// Version of Prometheus being deployed. The operator uses this
	// information to generate the Prometheus StatefulSet +
	// configuration files.
	// If not specified, the operator assumes the latest upstream
	// version of Prometheus available at the time when the version
	// of the operator was released.
	version?: string

	// VolumeMounts allows the configuration of additional
	// VolumeMounts.
	// VolumeMounts will be appended to other VolumeMounts in the
	// 'prometheus' container, that are generated as a result of
	// StorageSpec objects.
	volumeMounts?: [...{
		// Path within the container at which the volume should be
		// mounted. Must not contain ':'.
		mountPath: string

		// mountPropagation determines how mounts are propagated from the
		// host to container and the other way around. When not set,
		// MountPropagationNone is used. This field is beta in 1.10.
		mountPropagation?: string

		// This must match the Name of a Volume.
		name: string

		// Mounted read-only if true, read-write otherwise (false or
		// unspecified). Defaults to false.
		readOnly?: bool

		// Path within the volume from which the container's volume should
		// be mounted. Defaults to "" (volume's root).
		subPath?: string

		// Expanded path within the volume from which the container's
		// volume should be mounted. Behaves similarly to SubPath but
		// environment variable references $(VAR_NAME) are expanded using
		// the container's environment. Defaults to "" (volume's root).
		// SubPathExpr and SubPath are mutually exclusive.
		subPathExpr?: string
	}]

	// Volumes allows the configuration of additional volumes on the
	// output StatefulSet definition. Volumes specified will be
	// appended to other volumes that are generated as a result of
	// StorageSpec objects.
	volumes?: [...{
		// awsElasticBlockStore represents an AWS Disk resource that is
		// attached to a kubelet's host machine and then exposed to the
		// pod. More info:
		// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
		awsElasticBlockStore?: {
			// fsType is the filesystem type of the volume that you want to
			// mount. Tip: Ensure that the filesystem type is supported by
			// the host operating system. Examples: "ext4", "xfs", "ntfs".
			// Implicitly inferred to be "ext4" if unspecified. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			// TODO: how do we prevent errors in the filesystem from
			// compromising the machine
			fsType?: string

			// partition is the partition in the volume that you want to
			// mount. If omitted, the default is to mount by volume name.
			// Examples: For volume /dev/sda1, you specify the partition as
			// "1". Similarly, the volume partition for /dev/sda is "0" (or
			// you can leave the property empty).
			partition?: int

			// readOnly value true will force the readOnly setting in
			// VolumeMounts. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			readOnly?: bool

			// volumeID is unique ID of the persistent disk resource in AWS
			// (Amazon EBS volume). More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			volumeID: string
		}

		// azureDisk represents an Azure Data Disk mount on the host and
		// bind mount to the pod.
		azureDisk?: {
			// cachingMode is the Host Caching mode: None, Read Only, Read
			// Write.
			cachingMode?: string

			// diskName is the Name of the data disk in the blob storage
			diskName: string

			// diskURI is the URI of data disk in the blob storage
			diskURI: string

			// fsType is Filesystem type to mount. Must be a filesystem type
			// supported by the host operating system. Ex. "ext4", "xfs",
			// "ntfs". Implicitly inferred to be "ext4" if unspecified.
			fsType?: string

			// kind expected values are Shared: multiple blob disks per
			// storage account Dedicated: single blob disk per storage
			// account Managed: azure managed data disk (only in managed
			// availability set). defaults to shared
			kind?: string

			// readOnly Defaults to false (read/write). ReadOnly here will
			// force the ReadOnly setting in VolumeMounts.
			readOnly?: bool
		}

		// azureFile represents an Azure File Service mount on the host
		// and bind mount to the pod.
		azureFile?: {
			// readOnly defaults to false (read/write). ReadOnly here will
			// force the ReadOnly setting in VolumeMounts.
			readOnly?: bool

			// secretName is the name of secret that contains Azure Storage
			// Account Name and Key
			secretName: string

			// shareName is the azure share Name
			shareName: string
		}

		// cephFS represents a Ceph FS mount on the host that shares a
		// pod's lifetime
		cephfs?: {
			// monitors is Required: Monitors is a collection of Ceph monitors
			// More info:
			// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			monitors: [...string]

			// path is Optional: Used as the mounted root, rather than the
			// full Ceph tree, default is /
			path?: string

			// readOnly is Optional: Defaults to false (read/write). ReadOnly
			// here will force the ReadOnly setting in VolumeMounts. More
			// info:
			// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			readOnly?: bool

			// secretFile is Optional: SecretFile is the path to key ring for
			// User, default is /etc/ceph/user.secret More info:
			// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			secretFile?: string
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}

			// user is optional: User is the rados user name, default is admin
			// More info:
			// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			user?: string
		}

		// cinder represents a cinder volume attached and mounted on
		// kubelets host machine. More info:
		// https://examples.k8s.io/mysql-cinder-pd/README.md
		cinder?: {
			// fsType is the filesystem type to mount. Must be a filesystem
			// type supported by the host operating system. Examples: "ext4",
			// "xfs", "ntfs". Implicitly inferred to be "ext4" if
			// unspecified. More info:
			// https://examples.k8s.io/mysql-cinder-pd/README.md
			fsType?: string

			// readOnly defaults to false (read/write). ReadOnly here will
			// force the ReadOnly setting in VolumeMounts. More info:
			// https://examples.k8s.io/mysql-cinder-pd/README.md
			readOnly?: bool
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}

			// volumeID used to identify the volume in cinder. More info:
			// https://examples.k8s.io/mysql-cinder-pd/README.md
			volumeID: string
		}

		// configMap represents a configMap that should populate this
		// volume
		configMap?: {
			// defaultMode is optional: mode bits used to set permissions on
			// created files by default. Must be an octal value between 0000
			// and 0777 or a decimal value between 0 and 511. YAML accepts
			// both octal and decimal values, JSON requires decimal values
			// for mode bits. Defaults to 0644. Directories within the path
			// are not affected by this setting. This might be in conflict
			// with other options that affect the file mode, like fsGroup,
			// and the result can be other mode bits set.
			defaultMode?: int

			// items if unspecified, each key-value pair in the Data field of
			// the referenced ConfigMap will be projected into the volume as
			// a file whose name is the key and content is the value. If
			// specified, the listed keys will be projected into the
			// specified paths, and unlisted keys will not be present. If a
			// key is specified which is not present in the ConfigMap, the
			// volume setup will error unless it is marked optional. Paths
			// must be relative and may not contain the '..' path or start
			// with '..'.
			items?: [...{
				// key is the key to project.
				key: string

				// mode is Optional: mode bits used to set permissions on this
				// file. Must be an octal value between 0000 and 0777 or a
				// decimal value between 0 and 511. YAML accepts both octal and
				// decimal values, JSON requires decimal values for mode bits. If
				// not specified, the volume defaultMode will be used. This might
				// be in conflict with other options that affect the file mode,
				// like fsGroup, and the result can be other mode bits set.
				mode?: int

				// path is the relative path of the file to map the key to. May
				// not be an absolute path. May not contain the path element
				// '..'. May not start with the string '..'.
				path: string
			}]

			// Name of the referent. More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			// TODO: Add other useful fields. apiVersion, kind, uid?
			name?: string

			// optional specify whether the ConfigMap or its keys must be
			// defined
			optional?: bool
		}

		// csi (Container Storage Interface) represents ephemeral storage
		// that is handled by certain external CSI drivers (Beta
		// feature).
		csi?: {
			// driver is the name of the CSI driver that handles this volume.
			// Consult with your admin for the correct name as registered in
			// the cluster.
			driver: string

			// fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided,
			// the empty value is passed to the associated CSI driver which
			// will determine the default filesystem to apply.
			fsType?: string
			nodePublishSecretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}

			// readOnly specifies a read-only configuration for the volume.
			// Defaults to false (read/write).
			readOnly?: bool

			// volumeAttributes stores driver-specific properties that are
			// passed to the CSI driver. Consult your driver's documentation
			// for supported values.
			volumeAttributes?: {
				[string]: string
			}
		}

		// downwardAPI represents downward API about the pod that should
		// populate this volume
		downwardAPI?: {
			// Optional: mode bits to use on created files by default. Must be
			// a Optional: mode bits used to set permissions on created files
			// by default. Must be an octal value between 0000 and 0777 or a
			// decimal value between 0 and 511. YAML accepts both octal and
			// decimal values, JSON requires decimal values for mode bits.
			// Defaults to 0644. Directories within the path are not affected
			// by this setting. This might be in conflict with other options
			// that affect the file mode, like fsGroup, and the result can be
			// other mode bits set.
			defaultMode?: int

			// Items is a list of downward API volume file
			items?: [...{
				// Required: Selects a field of the pod: only annotations, labels,
				// name and namespace are supported.
				fieldRef?: {
					// Version of the schema the FieldPath is written in terms of,
					// defaults to "v1".
					apiVersion?: string

					// Path of the field to select in the specified API version.
					fieldPath: string
				}

				// Optional: mode bits used to set permissions on this file, must
				// be an octal value between 0000 and 0777 or a decimal value
				// between 0 and 511. YAML accepts both octal and decimal values,
				// JSON requires decimal values for mode bits. If not specified,
				// the volume defaultMode will be used. This might be in conflict
				// with other options that affect the file mode, like fsGroup,
				// and the result can be other mode bits set.
				mode?: int

				// Required: Path is the relative path name of the file to be
				// created. Must not be absolute or contain the '..' path. Must
				// be utf-8 encoded. The first item of the relative path must not
				// start with '..'
				path: string

				// Selects a resource of the container: only resources limits and
				// requests (limits.cpu, limits.memory, requests.cpu and
				// requests.memory) are currently supported.
				resourceFieldRef?: {
					// Container name: required for volumes, optional for env vars
					containerName?: string

					// Specifies the output format of the exposed resources, defaults
					// to "1"
					divisor?: (int | string) & {
						=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Required: resource to select
					resource: string
				}
			}]
		}

		// emptyDir represents a temporary directory that shares a pod's
		// lifetime. More info:
		// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
		emptyDir?: {
			// medium represents what type of storage medium should back this
			// directory. The default is "" which means to use the node's
			// default medium. Must be an empty string (default) or Memory.
			// More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
			medium?: string

			// sizeLimit is the total amount of local storage required for
			// this EmptyDir volume. The size limit is also applicable for
			// memory medium. The maximum usage on memory medium EmptyDir
			// would be the minimum value between the SizeLimit specified
			// here and the sum of memory limits of all containers in a pod.
			// The default is nil which means that the limit is undefined.
			// More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
			sizeLimit?: (int | string) & {
				=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}
		}
		ephemeral?: {
			// Will be used to create a stand-alone PVC to provision the
			// volume. The pod in which this EphemeralVolumeSource is
			// embedded will be the owner of the PVC, i.e. the PVC will be
			// deleted together with the pod. The name of the PVC will be
			// `<pod name>-<volume name>` where `<volume name>` is the name
			// from the `PodSpec.Volumes` array entry. Pod validation will
			// reject the pod if the concatenated name is not valid for a PVC
			// (for example, too long).
			// An existing PVC with that name that is not owned by the pod
			// will *not* be used for the pod to avoid using an unrelated
			// volume by mistake. Starting the pod is then blocked until the
			// unrelated PVC is removed. If such a pre-created PVC is meant
			// to be used by the pod, the PVC has to updated with an owner
			// reference to the pod once the pod exists. Normally this should
			// not be necessary, but it may be useful when manually
			// reconstructing a broken cluster.
			// This field is read-only and no changes will be made by
			// Kubernetes to the PVC after it has been created.
			// Required, must not be nil.
			volumeClaimTemplate?: {
				// May contain labels and annotations that will be copied into the
				// PVC when creating it. No other fields are allowed and will be
				// rejected during validation.
				metadata?: {}

				// The specification for the PersistentVolumeClaim. The entire
				// content is copied unchanged into the PVC that gets created
				// from this template. The same fields as in a
				// PersistentVolumeClaim are also valid here.
				spec: {
					// accessModes contains the desired access modes the volume should
					// have. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
					accessModes?: [...string]

					// dataSource field can be used to specify either: * An existing
					// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
					// * An existing PVC (PersistentVolumeClaim) If the provisioner
					// or an external controller can support the specified data
					// source, it will create a new volume based on the contents of
					// the specified data source. When the AnyVolumeDataSource
					// feature gate is enabled, dataSource contents will be copied to
					// dataSourceRef, and dataSourceRef contents will be copied to
					// dataSource when dataSourceRef.namespace is not specified. If
					// the namespace is specified, then dataSourceRef will not be
					// copied to dataSource.
					dataSource?: {
						// APIGroup is the group for the resource being referenced. If
						// APIGroup is not specified, the specified Kind must be in the
						// core API group. For any other third-party types, APIGroup is
						// required.
						apiGroup?: string

						// Kind is the type of resource being referenced
						kind: string

						// Name is the name of resource being referenced
						name: string
					}

					// dataSourceRef specifies the object from which to populate the
					// volume with data, if a non-empty volume is desired. This may
					// be any object from a non-empty API group (non core object) or
					// a PersistentVolumeClaim object. When this field is specified,
					// volume binding will only succeed if the type of the specified
					// object matches some installed volume populator or dynamic
					// provisioner. This field will replace the functionality of the
					// dataSource field and as such if both fields are non-empty,
					// they must have the same value. For backwards compatibility,
					// when namespace isn't specified in dataSourceRef, both fields
					// (dataSource and dataSourceRef) will be set to the same value
					// automatically if one of them is empty and the other is
					// non-empty. When namespace is specified in dataSourceRef,
					// dataSource isn't set to the same value and must be empty.
					// There are three important differences between dataSource and
					// dataSourceRef: * While dataSource only allows two specific
					// types of objects, dataSourceRef allows any non-core object, as
					// well as PersistentVolumeClaim objects. * While dataSource
					// ignores disallowed values (dropping them), dataSourceRef
					// preserves all values, and generates an error if a disallowed
					// value is specified. * While dataSource only allows local
					// objects, dataSourceRef allows objects in any namespaces.
					// (Beta) Using this field requires the AnyVolumeDataSource
					// feature gate to be enabled. (Alpha) Using the namespace field
					// of dataSourceRef requires the CrossNamespaceVolumeDataSource
					// feature gate to be enabled.
					dataSourceRef?: {
						// APIGroup is the group for the resource being referenced. If
						// APIGroup is not specified, the specified Kind must be in the
						// core API group. For any other third-party types, APIGroup is
						// required.
						apiGroup?: string

						// Kind is the type of resource being referenced
						kind: string

						// Name is the name of resource being referenced
						name: string

						// Namespace is the namespace of resource being referenced Note
						// that when a namespace is specified, a
						// gateway.networking.k8s.io/ReferenceGrant object is required in
						// the referent namespace to allow that namespace's owner to
						// accept the reference. See the ReferenceGrant documentation for
						// details. (Alpha) This field requires the
						// CrossNamespaceVolumeDataSource feature gate to be enabled.
						namespace?: string
					}

					// resources represents the minimum resources the volume should
					// have. If RecoverVolumeExpansionFailure feature is enabled
					// users are allowed to specify resource requirements that are
					// lower than previous value but must still be higher than
					// capacity recorded in the status field of the claim. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
					resources?: {
						// Limits describes the maximum amount of compute resources
						// allowed. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						limits?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Requests describes the minimum amount of compute resources
						// required. If Requests is omitted for a container, it defaults
						// to Limits if that is explicitly specified, otherwise to an
						// implementation-defined value. Requests cannot exceed Limits.
						// More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						requests?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}
					}

					// selector is a label query over volumes to consider for binding.
					selector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// storageClassName is the name of the StorageClass required by
					// the claim. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
					storageClassName?: string

					// volumeAttributesClassName may be used to set the
					// VolumeAttributesClass used by this claim. If specified, the
					// CSI driver will create or update the volume with the
					// attributes defined in the corresponding VolumeAttributesClass.
					// This has a different purpose than storageClassName, it can be
					// changed after the claim is created. An empty string value
					// means that no VolumeAttributesClass will be applied to the
					// claim but it's not allowed to reset this field to empty string
					// once it is set. If unspecified and the PersistentVolumeClaim
					// is unbound, the default VolumeAttributesClass will be set by
					// the persistentvolume controller if it exists. If the resource
					// referred to by volumeAttributesClass does not exist, this
					// PersistentVolumeClaim will be set to a Pending state, as
					// reflected by the modifyVolumeStatus field, until such as a
					// resource exists. More info:
					// https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass
					// (Alpha) Using this field requires the VolumeAttributesClass
					// feature gate to be enabled.
					volumeAttributesClassName?: string

					// volumeMode defines what type of volume is required by the
					// claim. Value of Filesystem is implied when not included in
					// claim spec.
					volumeMode?: string

					// volumeName is the binding reference to the PersistentVolume
					// backing this claim.
					volumeName?: string
				}
			}
		}

		// fc represents a Fibre Channel resource that is attached to a
		// kubelet's host machine and then exposed to the pod.
		fc?: {
			// fsType is the filesystem type to mount. Must be a filesystem
			// type supported by the host operating system. Ex. "ext4",
			// "xfs", "ntfs". Implicitly inferred to be "ext4" if
			// unspecified. TODO: how do we prevent errors in the filesystem
			// from compromising the machine
			fsType?: string

			// lun is Optional: FC target lun number
			lun?: int

			// readOnly is Optional: Defaults to false (read/write). ReadOnly
			// here will force the ReadOnly setting in VolumeMounts.
			readOnly?: bool

			// targetWWNs is Optional: FC target worldwide names (WWNs)
			targetWWNs?: [...string]

			// wwids Optional: FC volume world wide identifiers (wwids) Either
			// wwids or combination of targetWWNs and lun must be set, but
			// not both simultaneously.
			wwids?: [...string]
		}

		// flexVolume represents a generic volume resource that is
		// provisioned/attached using an exec based plugin.
		flexVolume?: {
			// driver is the name of the driver to use for this volume.
			driver: string

			// fsType is the filesystem type to mount. Must be a filesystem
			// type supported by the host operating system. Ex. "ext4",
			// "xfs", "ntfs". The default filesystem depends on FlexVolume
			// script.
			fsType?: string

			// options is Optional: this field holds extra command options if
			// any.
			options?: {
				[string]: string
			}

			// readOnly is Optional: defaults to false (read/write). ReadOnly
			// here will force the ReadOnly setting in VolumeMounts.
			readOnly?: bool
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}
		}

		// flocker represents a Flocker volume attached to a kubelet's
		// host machine. This depends on the Flocker control service
		// being running
		flocker?: {
			// datasetName is Name of the dataset stored as metadata -> name
			// on the dataset for Flocker should be considered as deprecated
			datasetName?: string

			// datasetUUID is the UUID of the dataset. This is unique
			// identifier of a Flocker dataset
			datasetUUID?: string
		}

		// gcePersistentDisk represents a GCE Disk resource that is
		// attached to a kubelet's host machine and then exposed to the
		// pod. More info:
		// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
		gcePersistentDisk?: {
			// fsType is filesystem type of the volume that you want to mount.
			// Tip: Ensure that the filesystem type is supported by the host
			// operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
			// inferred to be "ext4" if unspecified. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			// TODO: how do we prevent errors in the filesystem from
			// compromising the machine
			fsType?: string

			// partition is the partition in the volume that you want to
			// mount. If omitted, the default is to mount by volume name.
			// Examples: For volume /dev/sda1, you specify the partition as
			// "1". Similarly, the volume partition for /dev/sda is "0" (or
			// you can leave the property empty). More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			partition?: int

			// pdName is unique name of the PD resource in GCE. Used to
			// identify the disk in GCE. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			pdName: string

			// readOnly here will force the ReadOnly setting in VolumeMounts.
			// Defaults to false. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			readOnly?: bool
		}

		// gitRepo represents a git repository at a particular revision.
		// DEPRECATED: GitRepo is deprecated. To provision a container
		// with a git repo, mount an EmptyDir into an InitContainer that
		// clones the repo using git, then mount the EmptyDir into the
		// Pod's container.
		gitRepo?: {
			// directory is the target directory name. Must not contain or
			// start with '..'. If '.' is supplied, the volume directory will
			// be the git repository. Otherwise, if specified, the volume
			// will contain the git repository in the subdirectory with the
			// given name.
			directory?: string

			// repository is the URL
			repository: string

			// revision is the commit hash for the specified revision.
			revision?: string
		}

		// glusterfs represents a Glusterfs mount on the host that shares
		// a pod's lifetime. More info:
		// https://examples.k8s.io/volumes/glusterfs/README.md
		glusterfs?: {
			// endpoints is the endpoint name that details Glusterfs topology.
			// More info:
			// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			endpoints: string

			// path is the Glusterfs volume path. More info:
			// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			path: string

			// readOnly here will force the Glusterfs volume to be mounted
			// with read-only permissions. Defaults to false. More info:
			// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			readOnly?: bool
		}

		// hostPath represents a pre-existing file or directory on the
		// host machine that is directly exposed to the container. This
		// is generally used for system agents or other privileged things
		// that are allowed to see the host machine. Most containers will
		// NOT need this. More info:
		// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
		// --- TODO(jonesdl) We need to restrict who can use host
		// directory mounts and who can/can not mount host directories as
		// read/write.
		hostPath?: {
			// path of the directory on the host. If the path is a symlink, it
			// will follow the link to the real path. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
			path: string

			// type for HostPath Volume Defaults to "" More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
			type?: string
		}

		// iscsi represents an ISCSI Disk resource that is attached to a
		// kubelet's host machine and then exposed to the pod. More info:
		// https://examples.k8s.io/volumes/iscsi/README.md
		iscsi?: {
			// chapAuthDiscovery defines whether support iSCSI Discovery CHAP
			// authentication
			chapAuthDiscovery?: bool

			// chapAuthSession defines whether support iSCSI Session CHAP
			// authentication
			chapAuthSession?: bool

			// fsType is the filesystem type of the volume that you want to
			// mount. Tip: Ensure that the filesystem type is supported by
			// the host operating system. Examples: "ext4", "xfs", "ntfs".
			// Implicitly inferred to be "ext4" if unspecified. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
			// TODO: how do we prevent errors in the filesystem from
			// compromising the machine
			fsType?: string

			// initiatorName is the custom iSCSI Initiator Name. If
			// initiatorName is specified with iscsiInterface simultaneously,
			// new iSCSI interface <target portal>:<volume name> will be
			// created for the connection.
			initiatorName?: string

			// iqn is the target iSCSI Qualified Name.
			iqn: string

			// iscsiInterface is the interface Name that uses an iSCSI
			// transport. Defaults to 'default' (tcp).
			iscsiInterface?: string

			// lun represents iSCSI Target Lun number.
			lun: int

			// portals is the iSCSI Target Portal List. The portal is either
			// an IP or ip_addr:port if the port is other than default
			// (typically TCP ports 860 and 3260).
			portals?: [...string]

			// readOnly here will force the ReadOnly setting in VolumeMounts.
			// Defaults to false.
			readOnly?: bool
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}

			// targetPortal is iSCSI Target Portal. The Portal is either an IP
			// or ip_addr:port if the port is other than default (typically
			// TCP ports 860 and 3260).
			targetPortal: string
		}

		// name of the volume. Must be a DNS_LABEL and unique within the
		// pod. More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		name: string

		// nfs represents an NFS mount on the host that shares a pod's
		// lifetime More info:
		// https://kubernetes.io/docs/concepts/storage/volumes#nfs
		nfs?: {
			// path that is exported by the NFS server. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#nfs
			path: string

			// readOnly here will force the NFS export to be mounted with
			// read-only permissions. Defaults to false. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#nfs
			readOnly?: bool

			// server is the hostname or IP address of the NFS server. More
			// info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
			server: string
		}

		// persistentVolumeClaimVolumeSource represents a reference to a
		// PersistentVolumeClaim in the same namespace. More info:
		// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
		persistentVolumeClaim?: {
			// claimName is the name of a PersistentVolumeClaim in the same
			// namespace as the pod using this volume. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
			claimName: string

			// readOnly Will force the ReadOnly setting in VolumeMounts.
			// Default false.
			readOnly?: bool
		}

		// photonPersistentDisk represents a PhotonController persistent
		// disk attached and mounted on kubelets host machine
		photonPersistentDisk?: {
			// fsType is the filesystem type to mount. Must be a filesystem
			// type supported by the host operating system. Ex. "ext4",
			// "xfs", "ntfs". Implicitly inferred to be "ext4" if
			// unspecified.
			fsType?: string

			// pdID is the ID that identifies Photon Controller persistent
			// disk
			pdID: string
		}

		// portworxVolume represents a portworx volume attached and
		// mounted on kubelets host machine
		portworxVolume?: {
			// fSType represents the filesystem type to mount Must be a
			// filesystem type supported by the host operating system. Ex.
			// "ext4", "xfs". Implicitly inferred to be "ext4" if
			// unspecified.
			fsType?: string

			// readOnly defaults to false (read/write). ReadOnly here will
			// force the ReadOnly setting in VolumeMounts.
			readOnly?: bool

			// volumeID uniquely identifies a Portworx volume
			volumeID: string
		}

		// projected items for all in one resources secrets, configmaps,
		// and downward API
		projected?: {
			// defaultMode are the mode bits used to set permissions on
			// created files by default. Must be an octal value between 0000
			// and 0777 or a decimal value between 0 and 511. YAML accepts
			// both octal and decimal values, JSON requires decimal values
			// for mode bits. Directories within the path are not affected by
			// this setting. This might be in conflict with other options
			// that affect the file mode, like fsGroup, and the result can be
			// other mode bits set.
			defaultMode?: int

			// sources is the list of volume projections
			sources?: [...{
				// ClusterTrustBundle allows a pod to access the
				// `.spec.trustBundle` field of ClusterTrustBundle objects in an
				// auto-updating file.
				// Alpha, gated by the ClusterTrustBundleProjection feature gate.
				// ClusterTrustBundle objects can either be selected by name, or
				// by the combination of signer name and a label selector.
				// Kubelet performs aggressive normalization of the PEM contents
				// written into the pod filesystem. Esoteric PEM features such as
				// inter-block comments and block headers are stripped.
				// Certificates are deduplicated. The ordering of certificates
				// within the file is arbitrary, and Kubelet may change the order
				// over time.
				clusterTrustBundle?: {
					// Select all ClusterTrustBundles that match this label selector.
					// Only has effect if signerName is set. Mutually-exclusive with
					// name. If unset, interpreted as "match nothing". If set but
					// empty, interpreted as "match everything".
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// Select a single ClusterTrustBundle by object name.
					// Mutually-exclusive with signerName and labelSelector.
					name?: string

					// If true, don't block pod startup if the referenced
					// ClusterTrustBundle(s) aren't available. If using name, then
					// the named ClusterTrustBundle is allowed not to exist. If using
					// signerName, then the combination of signerName and
					// labelSelector is allowed to match zero ClusterTrustBundles.
					optional?: bool

					// Relative path from the volume root to write the bundle.
					path: string

					// Select all ClusterTrustBundles that match this signer name.
					// Mutually-exclusive with name. The contents of all selected
					// ClusterTrustBundles will be unified and deduplicated.
					signerName?: string
				}

				// configMap information about the configMap data to project
				configMap?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced ConfigMap will be projected into the volume as
					// a file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the ConfigMap, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// optional specify whether the ConfigMap or its keys must be
					// defined
					optional?: bool
				}
				downwardAPI?: {
					// Items is a list of DownwardAPIVolume file
					items?: [...{
						// Required: Selects a field of the pod: only annotations, labels,
						// name and namespace are supported.
						fieldRef?: {
							// Version of the schema the FieldPath is written in terms of,
							// defaults to "v1".
							apiVersion?: string

							// Path of the field to select in the specified API version.
							fieldPath: string
						}

						// Optional: mode bits used to set permissions on this file, must
						// be an octal value between 0000 and 0777 or a decimal value
						// between 0 and 511. YAML accepts both octal and decimal values,
						// JSON requires decimal values for mode bits. If not specified,
						// the volume defaultMode will be used. This might be in conflict
						// with other options that affect the file mode, like fsGroup,
						// and the result can be other mode bits set.
						mode?: int

						// Required: Path is the relative path name of the file to be
						// created. Must not be absolute or contain the '..' path. Must
						// be utf-8 encoded. The first item of the relative path must not
						// start with '..'
						path: string

						// Selects a resource of the container: only resources limits and
						// requests (limits.cpu, limits.memory, requests.cpu and
						// requests.memory) are currently supported.
						resourceFieldRef?: {
							// Container name: required for volumes, optional for env vars
							containerName?: string

							// Specifies the output format of the exposed resources, defaults
							// to "1"
							divisor?: (int | string) & {
								=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Required: resource to select
							resource: string
						}
					}]
				}

				// secret information about the secret data to project
				secret?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced Secret will be projected into the volume as a
					// file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the Secret, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// optional field specify whether the Secret or its key must be
					// defined
					optional?: bool
				}

				// serviceAccountToken is information about the
				// serviceAccountToken data to project
				serviceAccountToken?: {
					// audience is the intended audience of the token. A recipient of
					// a token must identify itself with an identifier specified in
					// the audience of the token, and otherwise should reject the
					// token. The audience defaults to the identifier of the
					// apiserver.
					audience?: string

					// expirationSeconds is the requested duration of validity of the
					// service account token. As the token approaches expiration, the
					// kubelet volume plugin will proactively rotate the service
					// account token. The kubelet will start trying to rotate the
					// token if the token is older than 80 percent of its time to
					// live or if the token is older than 24 hours.Defaults to 1 hour
					// and must be at least 10 minutes.
					expirationSeconds?: int

					// path is the path relative to the mount point of the file to
					// project the token into.
					path: string
				}
			}]
		}

		// quobyte represents a Quobyte mount on the host that shares a
		// pod's lifetime
		quobyte?: {
			// group to map volume access to Default is no group
			group?: string

			// readOnly here will force the Quobyte volume to be mounted with
			// read-only permissions. Defaults to false.
			readOnly?: bool

			// registry represents a single or multiple Quobyte Registry
			// services specified as a string as host:port pair (multiple
			// entries are separated with commas) which acts as the central
			// registry for volumes
			registry: string

			// tenant owning the given Quobyte volume in the Backend Used with
			// dynamically provisioned Quobyte volumes, value is set by the
			// plugin
			tenant?: string

			// user to map volume access to Defaults to serivceaccount user
			user?: string

			// volume is a string that references an already created Quobyte
			// volume by name.
			volume: string
		}

		// rbd represents a Rados Block Device mount on the host that
		// shares a pod's lifetime. More info:
		// https://examples.k8s.io/volumes/rbd/README.md
		rbd?: {
			// fsType is the filesystem type of the volume that you want to
			// mount. Tip: Ensure that the filesystem type is supported by
			// the host operating system. Examples: "ext4", "xfs", "ntfs".
			// Implicitly inferred to be "ext4" if unspecified. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO:
			// how do we prevent errors in the filesystem from compromising
			// the machine
			fsType?: string

			// image is the rados image name. More info:
			// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			image: string

			// keyring is the path to key ring for RBDUser. Default is
			// /etc/ceph/keyring. More info:
			// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			keyring?: string

			// monitors is a collection of Ceph monitors. More info:
			// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			monitors: [...string]

			// pool is the rados pool name. Default is rbd. More info:
			// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			pool?: string

			// readOnly here will force the ReadOnly setting in VolumeMounts.
			// Defaults to false. More info:
			// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			readOnly?: bool
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}

			// user is the rados user name. Default is admin. More info:
			// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			user?: string
		}

		// scaleIO represents a ScaleIO persistent volume attached and
		// mounted on Kubernetes nodes.
		scaleIO?: {
			// fsType is the filesystem type to mount. Must be a filesystem
			// type supported by the host operating system. Ex. "ext4",
			// "xfs", "ntfs". Default is "xfs".
			fsType?: string

			// gateway is the host address of the ScaleIO API Gateway.
			gateway: string

			// protectionDomain is the name of the ScaleIO Protection Domain
			// for the configured storage.
			protectionDomain?: string

			// readOnly Defaults to false (read/write). ReadOnly here will
			// force the ReadOnly setting in VolumeMounts.
			readOnly?: bool
			secretRef: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}

			// sslEnabled Flag enable/disable SSL communication with Gateway,
			// default false
			sslEnabled?: bool

			// storageMode indicates whether the storage for a volume should
			// be ThickProvisioned or ThinProvisioned. Default is
			// ThinProvisioned.
			storageMode?: string

			// storagePool is the ScaleIO Storage Pool associated with the
			// protection domain.
			storagePool?: string

			// system is the name of the storage system as configured in
			// ScaleIO.
			system: string

			// volumeName is the name of a volume already created in the
			// ScaleIO system that is associated with this volume source.
			volumeName?: string
		}

		// secret represents a secret that should populate this volume.
		// More info:
		// https://kubernetes.io/docs/concepts/storage/volumes#secret
		secret?: {
			// defaultMode is Optional: mode bits used to set permissions on
			// created files by default. Must be an octal value between 0000
			// and 0777 or a decimal value between 0 and 511. YAML accepts
			// both octal and decimal values, JSON requires decimal values
			// for mode bits. Defaults to 0644. Directories within the path
			// are not affected by this setting. This might be in conflict
			// with other options that affect the file mode, like fsGroup,
			// and the result can be other mode bits set.
			defaultMode?: int

			// items If unspecified, each key-value pair in the Data field of
			// the referenced Secret will be projected into the volume as a
			// file whose name is the key and content is the value. If
			// specified, the listed keys will be projected into the
			// specified paths, and unlisted keys will not be present. If a
			// key is specified which is not present in the Secret, the
			// volume setup will error unless it is marked optional. Paths
			// must be relative and may not contain the '..' path or start
			// with '..'.
			items?: [...{
				// key is the key to project.
				key: string

				// mode is Optional: mode bits used to set permissions on this
				// file. Must be an octal value between 0000 and 0777 or a
				// decimal value between 0 and 511. YAML accepts both octal and
				// decimal values, JSON requires decimal values for mode bits. If
				// not specified, the volume defaultMode will be used. This might
				// be in conflict with other options that affect the file mode,
				// like fsGroup, and the result can be other mode bits set.
				mode?: int

				// path is the relative path of the file to map the key to. May
				// not be an absolute path. May not contain the path element
				// '..'. May not start with the string '..'.
				path: string
			}]

			// optional field specify whether the Secret or its keys must be
			// defined
			optional?: bool

			// secretName is the name of the secret in the pod's namespace to
			// use. More info:
			// https://kubernetes.io/docs/concepts/storage/volumes#secret
			secretName?: string
		}

		// storageOS represents a StorageOS volume attached and mounted on
		// Kubernetes nodes.
		storageos?: {
			// fsType is the filesystem type to mount. Must be a filesystem
			// type supported by the host operating system. Ex. "ext4",
			// "xfs", "ntfs". Implicitly inferred to be "ext4" if
			// unspecified.
			fsType?: string

			// readOnly defaults to false (read/write). ReadOnly here will
			// force the ReadOnly setting in VolumeMounts.
			readOnly?: bool
			secretRef?: {
				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string
			}

			// volumeName is the human-readable name of the StorageOS volume.
			// Volume names are only unique within a namespace.
			volumeName?: string

			// volumeNamespace specifies the scope of the volume within
			// StorageOS. If no namespace is specified then the Pod's
			// namespace will be used. This allows the Kubernetes name
			// scoping to be mirrored within StorageOS for tighter
			// integration. Set VolumeName to any name to override the
			// default behaviour. Set to "default" if you are not using
			// namespaces within StorageOS. Namespaces that do not pre-exist
			// within StorageOS will be created.
			volumeNamespace?: string
		}

		// vsphereVolume represents a vSphere volume attached and mounted
		// on kubelets host machine
		vsphereVolume?: {
			// fsType is filesystem type to mount. Must be a filesystem type
			// supported by the host operating system. Ex. "ext4", "xfs",
			// "ntfs". Implicitly inferred to be "ext4" if unspecified.
			fsType?: string

			// storagePolicyID is the storage Policy Based Management (SPBM)
			// profile ID associated with the StoragePolicyName.
			storagePolicyID?: string

			// storagePolicyName is the storage Policy Based Management (SPBM)
			// profile name.
			storagePolicyName?: string

			// volumePath is the path that identifies vSphere volume vmdk
			volumePath: string
		}
	}]

	// Configures compression of the write-ahead log (WAL) using
	// Snappy.
	// WAL compression is enabled by default for Prometheus >= 2.20.0
	// Requires Prometheus v2.11.0 and above.
	walCompression?: bool

	// Defines the configuration of the Prometheus web server.
	web?: {
		// Defines HTTP parameters for web server.
		httpConfig?: {
			// List of headers that can be added to HTTP responses.
			headers?: {
				// Set the Content-Security-Policy header to HTTP responses. Unset
				// if blank.
				contentSecurityPolicy?: string

				// Set the Strict-Transport-Security header to HTTP responses.
				// Unset if blank. Please make sure that you use this with care
				// as this header might force browsers to load Prometheus and the
				// other applications hosted on the same domain and subdomains
				// over HTTPS.
				// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
				strictTransportSecurity?: string

				// Set the X-Content-Type-Options header to HTTP responses. Unset
				// if blank. Accepted value is nosniff.
				// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
				xContentTypeOptions?: "" | "NoSniff"

				// Set the X-Frame-Options header to HTTP responses. Unset if
				// blank. Accepted values are deny and sameorigin.
				// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
				xFrameOptions?: "" | "Deny" | "SameOrigin"

				// Set the X-XSS-Protection header to all responses. Unset if
				// blank.
				// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
				xXSSProtection?: string
			}

			// Enable HTTP/2 support. Note that HTTP/2 is only supported with
			// TLS. When TLSConfig is not configured, HTTP/2 will be
			// disabled. Whenever the value of the field changes, a rolling
			// update will be triggered.
			http2?: bool
		}

		// Defines the maximum number of simultaneous connections A zero
		// value means that Prometheus doesn't accept any incoming
		// connection.
		maxConnections?: >=0 & int

		// The prometheus web page title.
		pageTitle?: string

		// Defines the TLS parameters for HTTPS.
		tlsConfig?: {
			// Contains the TLS certificate for the server.
			cert: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// List of supported cipher suites for TLS versions up to TLS 1.2.
			// If empty, Go default cipher suites are used. Available cipher
			// suites are documented in the go documentation:
			// https://golang.org/pkg/crypto/tls/#pkg-constants
			cipherSuites?: [...string]

			// Contains the CA certificate for client certificate
			// authentication to the server.
			client_ca?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					// TODO: Add other useful fields. apiVersion, kind, uid?
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Server policy for client authentication. Maps to ClientAuth
			// Policies. For more detail on clientAuth options:
			// https://golang.org/pkg/crypto/tls/#ClientAuthType
			clientAuthType?: string

			// Elliptic curves that will be used in an ECDHE handshake, in
			// preference order. Available curves are documented in the go
			// documentation: https://golang.org/pkg/crypto/tls/#CurveID
			curvePreferences?: [...string]

			// Secret containing the TLS key for the server.
			keySecret: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key: string

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				// TODO: Add other useful fields. apiVersion, kind, uid?
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Maximum TLS version that is acceptable. Defaults to TLS13.
			maxVersion?: string

			// Minimum TLS version that is acceptable. Defaults to TLS12.
			minVersion?: string

			// Controls whether the server selects the client's most preferred
			// cipher suite, or the server's most preferred cipher suite. If
			// true then the server's preference, as expressed in the order
			// of elements in cipherSuites, is used.
			preferServerCipherSuites?: bool
		}
	}
}
