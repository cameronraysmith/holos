import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';

# Quickstart Guide

This guide shows you the basics of how Holos.  You'll deploy a Helm chart to
Kubernetes using a Component to see how Holos makes the process safer, easier,
and more consistent.

## What you'll need {#Requirements}

You'll need the following tools installed to complete this guide.

1. [holos](/docs/install) - to build the platform.
2. [helm](https://helm.sh/docs/intro/install/) - to render Holos components that
wrap upstream Helm charts.

Optionally, if you'd like to apply the rendered manifests to a real cluster
you'll need:

1. [k3d](https://k3d.io/#installation) - to provide a Kubernetes API server.
2. [OrbStack](https://docs.orbstack.dev/install) or
[Docker](https://docs.docker.com/get-docker/) - to use k3d.
3. [kubectl](https://kubernetes.io/docs/tasks/tools/) - to interact with
kubernetes.

## Install Holos

Install Holos with the following command or other methods listed on the
[Installation](/docs/install/) page.

```bash
go install github.com/holos-run/holos/cmd/holos@latest
```

## Git repository

Start by initializing an empty Git repository.  Holos is designed to operate
against local files in a Git repository.

<Tabs groupId="init">
  <TabItem value="command" label="Command">
    ```bash
    mkdir holos-quickstart
    cd holos-quickstart
    git init
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    Initialized empty Git repository in /holos-quickstart/.git/
    ```
  </TabItem>
</Tabs>

This guide assumes commands are run from the root directory of this Git
repository unless otherwise stated.

## Generate the Platform {#Generate-Platform}

Generate the Platform code in the repository root.  A Platform refers to all of
the software holistically integrated to provide a software development platform
for your organization.  In this guide the platform will contain a single
Component to demonstrate how the concepts fit together.

```bash
holos generate platform quickstart
```

Commit the generated platform config to the repository.

<Tabs groupId="commit-platform">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos generate platform quickstart - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main (root-commit) 0b17b7f] holos generate platform quickstart
     213 files changed, 72349 insertions(+)
     ...
    ```
  </TabItem>
</Tabs>

## Generate a Component {#generate-component}

The platform you generated is empty.  Generate the CUE code definition for a
Component that wraps the podinfo Helm chart.

<Tabs groupId="gen-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos generate component helm podinfo
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    generated component
    ```
  </TabItem>
</Tabs>

This command produces two files.  A leaf `components/podinfo/podinfo.gen.cue`
file, and a root `podinfo.gen.cue` file.  Holos takes advantage of the fact that
[order is irrelevant](https://cuelang.org/docs/tour/basics/order-irrelevance/)
in CUE to register the component with the Platform specification by adding a
file to the root of the Git repository in addition to defining the component
itself in the leaf component directory.

The Helm chart Component is defined in the `components/podinfo/podinfo.cue`
file, for example:

<Tabs groupId="podinfo-files">
  <TabItem value="components/podinfo/podinfo.gen.cue" label="Leaf">
    `components/podinfo/podinfo.gen.cue`
    ```cue
    package holos

    // Produce a helm chart build plan.
    (#Helm & Chart).Output

    let Chart = {
      Name:      "podinfo"
      Version:   "6.6.2"
      Namespace: "default"

      Repo: name: "podinfo"
      Repo: url:  "https://stefanprodan.github.io/podinfo"

      Values: {}
    }
    ```
  </TabItem>
  <TabItem value="podinfo.gen.cue" label="Root">
    `podinfo.gen.cue`
    ```cue
    package holos

    // Manage podinfo on workload clusters only
    for Cluster in #Fleets.workload.clusters {
      #Platform: Components: "\(Cluster.name)/podinfo": {
        path:    "components/podinfo"
        cluster: Cluster.name
      }
    }
    ```
  </TabItem>
</Tabs>

In this example we're providing the minimal information about the Helm chart we
want to manage.  The name, version, Kubernetes namespace to deploy into, and the
chart repository location.

This chart deploys cleanly with no values provided, but we include an empty
Values struct to illustrate how Holos improves the consistency and safety of
Helm by taking advantage the strong type checking in CUE.  Shared values,
such as the organization domain name, can safely be passed to all Components
across all clusters in the Platform by defining them at the root of the
configuration.

Commit the generated component config to the repository.

<Tabs groupId="commit-component">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos generate component helm podinfo - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main cc0e90c] holos generate component helm podinfo
     2 files changed, 24 insertions(+)
     create mode 100644 components/podinfo/podinfo.gen.cue
     create mode 100644 podinfo.gen.cue
    ```
  </TabItem>
</Tabs>

## Render the Component

Individual components can be rendered without needing to be included in a
Platform spec, useful when developing a new component.

<Tabs groupId="render-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos render component ./components/podinfo --cluster-name=default
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    cached
    rendered podinfo
    ```
  </TabItem>
</Tabs>

First, the command caches the helm chart locally to speed up subsequent
renderings.  Then the command executes helm to produce the output which is
written into the deploy directory.

<Tabs groupId="tree-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        └── default
            └── components
                └── podinfo
                    └── podinfo.gen.yaml

    5 directories, 1 file
    ```
  </TabItem>
</Tabs>

The component is deployed to one cluster named default. The same component is
often deployed to multiple clusters, for example east and west for reliability.

:::tip

This example is equivalent to executing `helm template` on the chart and saving
the output to a file.  Holos simplifies this task by making it safer and more
consistent across multiple charts.

:::

## Mix in an ArgoCD Application

So far we've seen how Holos is a convenient wrapper around Helm, but we haven't
yet seen how it makes it easier to consistently and safely manage all of the
software that goes into a platform.  We'll mix in an ArgoCD
[Application][application] resource to manage the podinfo Component with GitOps.
We'll define this configuration in a way that is automatically and consistently
re-used across all Components added to the Platform in the future, including
Components which are not Helm charts.

Create a new file named `argocd.cue` in the root of your git repository with the
following contents:

<Tabs groupId="argocd-config">
  <TabItem value="command" label="argocd.cue">
    ```cue
    package holos

    #ArgoConfig: {
      Enabled: true
      RepoURL: "https://example.com/holos-quickstart.git"
    }
    ```
  </TabItem>
  <TabItem value="note" label="Note">
    If you plan to apply the rendered output to a real cluster, change the RepoURL
    to the url of the git repository you created in this guide.  It is sufficient to
    keep the example URL if you're getting a feel for Holos and inspecting the
    rendered output without applying it to a live cluster.
  </TabItem>
</Tabs>

With this file in place, render the component again.

<Tabs groupId="render-podinfo-argocd">
  <TabItem value="command" label="Command">
    ```bash
    holos render component ./components/podinfo --cluster-name=default
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    wrote deploy file
    rendered gitops/podinfo
    rendered podinfo
    ```
  </TabItem>
</Tabs>

Holos uses the locally cached copy of the chart to render the output to improve
performance and reliability.  Then, the Helm template output is rendered along
with an additional ArgoCD Application resource for GitOps in the
`podinfo.application.gen.yaml` file.

:::tip

By defining the ArgoCD configuration at the root, we again take advantage of the
fact that [order is
irrelevant](https://cuelang.org/docs/tour/basics/order-irrelevance/) in CUE.

:::

Defining the configuration at the root causes all of the leaf Components to take
on the ArgoCD configuration and render an Application resource for the
Component.

<Tabs groupId="tree-podinfo-argocd">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        └── default
            ├── components
            │   └── podinfo
            │       └── podinfo.gen.yaml
            └── gitops
                └── podinfo.application.gen.yaml

    6 directories, 2 files
    ```
  </TabItem>
</Tabs>

Note the new `podinfo.application.gen.yaml` created by enabling the ArgoCD in
the Helm component.  The Application resource in the file looks like the
following.

<Tabs groupId="podinfo-application">
  <TabItem value="file" label="podinfo.application.gen.yaml">
    ```yaml
    apiVersion: argoproj.io/v1alpha1
    kind: Application
    metadata:
      name: podinfo
      namespace: argocd
    spec:
      destination:
        server: https://kubernetes.default.svc
      project: default
      source:
        path: ./deploy/clusters/default/components/podinfo
        repoURL: https://example.com/holos-quickstart.git
        targetRevision: main
    ```
  </TabItem>
</Tabs>

:::tip

Holos will generate a similar Application resource for all additional Components
added to your Platform.

:::

Finally, add and commit the results to your platform Git repository.

<Tabs groupId="commit-argo">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos render component ./components/podinfo --cluster-name=default"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main f95cef1] holos render component ./components/podinfo --cluster-name=default
     3 files changed, 134 insertions(+)
     create mode 100644 argocd.cue
     create mode 100644 deploy/clusters/default/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/default/gitops/podinfo.application.gen.yaml
    ```
  </TabItem>
</Tabs>

In this section we learned how Holos provides a simple way to add an ArgoCD
Application resource for the podinfo Component which wraps a Helm chart.  Holos
provides consistency by managing an Application resource for every Component
added to the platform, all by defining the configuration of ArgoCD in the
`argocd.cue` file in the root of the Git repository.

## Workload Clusters

So far, we've generated a Platform and a registered podinfo Component with the
Platform, but we have not yet defined a workload cluster.  Rendering the
Platform has no effect because the podinfo Component applies only to workload
Clusters.

Create a new file named `clusters.cue` in the root of your git repository with
the following content:

<Tabs groupId="clusters">
  <TabItem value="clusters.cue" label="clusters.cue">
    ```cue
    package holos

    // Define two workload clusters for disaster recovery.
    #Fleets: workload: clusters: {
      east: _
      west: _
    }
    ```
  </TabItem>
</Tabs>

In this file we're defining two Clusters named `east` and `west`.  This example
demonstrates how Holos simplifies the process of configuring multiple clusters
with nearly identical configuration, useful for assigning one cluster among a
set as the primary.  Clusters which are not primary can then be configured to
automatically follow the leader.  The primary can be configured to automatically
restore persistent data from backups stored in buckets.

:::tip

Automatic database backup and restore is an advanced topic made possible by
Cloud Native PG.  Check back for a guide on this topic and additional Day 2
operations topics.

:::

## Render the Platform {#render-platform}

With workload clusters defined render the platform to render the podinfo
Component for each cluster.

<Tabs groupId="render-platform">
  <TabItem value="command" label="Command">
    ```bash
    holos render platform ./platform
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    rendered components/podinfo for cluster west in 99.480792ms
    rendered components/podinfo for cluster east in 99.882667ms
    ```
  </TabItem>
</Tabs>

The render platform command iterates over every Cluster and renders each
Component integrated into the Platform.  Note how two additional sub-trees have
been created under the deploy directory, one for each cluster `east` and `west`.

<Tabs groupId="tree-platform">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        ├── default
        │   ├── components
        │   │   └── podinfo
        │   │       └── podinfo.gen.yaml
        │   └── gitops
        │       └── podinfo.application.gen.yaml
        ├── east
        │   ├── components
        │   │   └── podinfo
        │   │       └── podinfo.gen.yaml
        │   └── gitops
        │       └── podinfo.application.gen.yaml
        └── west
            ├── components
            │   └── podinfo
            │       └── podinfo.gen.yaml
            └── gitops
                └── podinfo.application.gen.yaml

    14 directories, 6 files
    ```
  </TabItem>
</Tabs>

Holos provides consistency and safety to these changes by ensuring the ArgoCD
Application is defined in a manner unified with the configuration we placed at
the root.  Note how the Application resource is generated for each cluster.

<Tabs groupId="applications">
  <TabItem value="east" label="east">
  `deploy/clusters/east/gitops/podinfo.application.gen.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/east/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
  <TabItem value="west" label="west">
  `deploy/clusters/west/gitops/podinfo.application.gen.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/west/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
  <TabItem value="default" label="default">
  `deploy/clusters/default/gitops/podinfo.application.gen.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/default/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
</Tabs>

Add and commit the rendered platform with east and west workload clusters.

<Tabs groupId="commit-render-platform">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos render platform ./platform - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main 5aebcf5] holos render platform ./platform - 0.93.2
     5 files changed, 263 insertions(+)
     create mode 100644 clusters.cue
     create mode 100644 deploy/clusters/east/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/east/gitops/podinfo.application.gen.yaml
     create mode 100644 deploy/clusters/west/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/west/gitops/podinfo.application.gen.yaml
    ```
  </TabItem>
</Tabs>

## Quickstart Recap {#quickstart-recap}

In this guide we learned how to:

1. Install Holos.
2. Generate a Git repository for the Platform config.
3. Create a Component that wraps the upstream podinfo Helm Chart without modifications.
4. Render individual components.
5. Mix in an ArgoCD Application resource to every Component in the Platform.

[application]: https://argo-cd.readthedocs.io/en/stable/user-guide/application-specification/
