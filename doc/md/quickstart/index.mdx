import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';

# Quickstart Guide

In this guide you'll experience how Holos makes the process of operating a
platform safer, easier, and more consistent. We'll use Holos to manage a vendor
provided Helm chart as a Component.  Next, we'll mix-in our own custom resources
to manage the component with GitOps.  Finally, we'll see how Holos makes it
safer and easier to maintain software over time by surfacing the exact changes
that will be made when upgrading the vendor's chart to a new version.

## What you'll need {#Requirements}

You'll need the following tools installed to complete this guide.

1. [holos](/docs/install) - to build the platform.
2. [helm](https://helm.sh/docs/intro/install/) - to render Holos components that
wrap upstream Helm charts.

Optionally, if you'd like to apply the rendered manifests to a real cluster
you'll need:

1. [k3d](https://k3d.io/#installation) - to provide a Kubernetes API server.
2. [OrbStack](https://docs.orbstack.dev/install) or
[Docker](https://docs.docker.com/get-docker/) - to use k3d.
3. [kubectl](https://kubernetes.io/docs/tasks/tools/) - to interact with
kubernetes.

## Install Holos

Install Holos with the following command or other methods listed on the
[Installation](/docs/install/) page.

```bash
go install github.com/holos-run/holos/cmd/holos@latest
```

## Git repository

Start by initializing an empty Git repository.  Holos is designed to operate
against local files in a Git repository.

<Tabs groupId="init">
  <TabItem value="command" label="Command">
    ```bash
    mkdir holos-quickstart
    cd holos-quickstart
    git init
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    Initialized empty Git repository in /holos-quickstart/.git/
    ```
  </TabItem>
</Tabs>

This guide assumes commands are run from the root directory of this Git
repository unless otherwise stated.

## Generate the Platform {#Generate-Platform}

Generate the Platform code in the repository root.  A Platform refers to all of
the software holistically integrated to provide a software development platform
for your organization.  In this guide the platform will contain a single
Component to demonstrate how the concepts fit together.

```bash
holos generate platform quickstart
```

Commit the generated platform config to the repository.

<Tabs groupId="commit-platform">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos generate platform quickstart - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main (root-commit) 0b17b7f] holos generate platform quickstart
     213 files changed, 72349 insertions(+)
     ...
    ```
  </TabItem>
</Tabs>

## Generate a Component {#generate-component}

The platform you generated is empty.  Generate the CUE code that defines a
Helm Component with the following command.

<Tabs groupId="gen-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos generate component helm podinfo --component-version 6.6.1
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    generated component
    ```
  </TabItem>
</Tabs>

The `--component-version 6.6.1` flag intentionally installs an older release.
We'll see how Holos helps with software upgrades later in this guide.

The generate component command produces two files.  A leaf
`components/podinfo/podinfo.gen.cue` file, and a root `podinfo.gen.cue` file.
Holos takes advantage of the fact that [order is
irrelevant](https://cuelang.org/docs/tour/basics/order-irrelevance/) in CUE to
register the component with the Platform by adding a file to the root of the Git
repository.  The second file defines the component itself in the leaf component
directory.

<Tabs groupId="podinfo-files">
  <TabItem value="components/podinfo/podinfo.gen.cue" label="Leaf">
    `components/podinfo/podinfo.gen.cue`
    ```cue showLineNumbers
    package holos

    // Produce a helm chart build plan.
    (#Helm & Chart).Output

    let Chart = {
      Name:      "podinfo"
      Version:   "6.6.2"
      Namespace: "default"

      Repo: name: "podinfo"
      Repo: url:  "https://stefanprodan.github.io/podinfo"

      Values: {}
    }
    ```
  </TabItem>
  <TabItem value="podinfo.gen.cue" label="Root">
    `podinfo.gen.cue`
    ```cue showLineNumbers
    package holos

    // Manage podinfo on workload clusters only
    for Cluster in #Fleets.workload.clusters {
      #Platform: Components: "\(Cluster.name)/podinfo": {
        path:    "components/podinfo"
        cluster: Cluster.name
      }
    }
    ```
  </TabItem>
</Tabs>

In this example we're providing the minimal information about the Helm chart we
want to manage.  The name, version, Kubernetes namespace to deploy into, and the
chart repository location.

This chart deploys cleanly with no values provided, but we include an empty
Values struct to illustrate how Holos improves the consistency and safety of
Helm by taking advantage of the strong type checking in CUE.  Shared values,
such as the organization domain name, can safely be passed to all Components
across all clusters in the Platform by defining them at the root of the
configuration.

Commit the generated component config to the repository.

<Tabs groupId="commit-component">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos generate component helm podinfo - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main cc0e90c] holos generate component helm podinfo
     2 files changed, 24 insertions(+)
     create mode 100644 components/podinfo/podinfo.gen.cue
     create mode 100644 podinfo.gen.cue
    ```
  </TabItem>
</Tabs>

## Render the Component

Individual components can be rendered without needing to be included in a
Platform spec, useful when developing a new component.

<Tabs groupId="render-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos render component ./components/podinfo --cluster-name=default
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    cached
    rendered podinfo
    ```
  </TabItem>
</Tabs>

First, the command caches the helm chart locally to speed up subsequent
renderings.  Then the command executes helm to produce the output which is
written into the deploy directory.

<Tabs groupId="tree-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        └── default
            └── components
                └── podinfo
                    └── podinfo.gen.yaml

    5 directories, 1 file
    ```
  </TabItem>
</Tabs>

The component is deployed to one cluster named default. The same component is
often deployed to multiple clusters, for example east and west for reliability.

:::tip

This example is equivalent to executing `helm template` on the chart and saving
the output to a file.  Holos simplifies this task by making it safer and more
consistent across multiple charts.

:::

## Mix in an ArgoCD Application

We've seen how Holos works with Helm, but we haven't seen how Holos makes it
easier to consistently and safely manage all of the software that goes into a
Platform.

Holos offers the ability to easily mix-in resources that differentiate your
Platform.  We'll use this feature to mix-in an ArgoCD [Application][application]
to manage the podinfo Component with GitOps.  We'll define this configuration in
a way that is automatically and consistently re-used across all Components added
to the Platform in the future.

Create a new file named `argocd.cue` in the root of your git repository with the
following contents:

<Tabs groupId="argocd-config">
  <TabItem value="command" label="argocd.cue">
    ```cue showLineNumbers
    package holos

    #ArgoConfig: {
      Enabled: true
      RepoURL: "https://example.com/holos-quickstart.git"
    }
    ```
  </TabItem>
</Tabs>

:::tip
If you plan to apply the rendered output to a real cluster, change the
example.com RepoURL to the url of the git repository you created in this guide.
You don't need to change the example if you're getting a feel for Holos by
inspecting the rendered output without applying it to a live cluster.
:::

With this file in place, render the component again.

<Tabs groupId="render-podinfo-argocd">
  <TabItem value="command" label="Command">
    ```bash
    holos render component ./components/podinfo --cluster-name=default
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    wrote deploy file
    rendered gitops/podinfo
    rendered podinfo
    ```
  </TabItem>
</Tabs>

Holos uses the locally cached copy of the chart to render the output to improve
performance and reliability.  Then, the Helm template output is rendered along
with an additional ArgoCD Application resource for GitOps in the
`podinfo.application.gen.yaml` file.

:::tip

By defining the ArgoCD configuration at the root, we again take advantage of the
fact that [order is
irrelevant](https://cuelang.org/docs/tour/basics/order-irrelevance/) in CUE.

:::

Defining the configuration at the root causes all future leaf Components to take
on the ArgoCD configuration and render an Application manifest to manage the
component with GitOps.

<Tabs groupId="tree-podinfo-argocd">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        └── default
            ├── components
            │   └── podinfo
            │       └── podinfo.gen.yaml
            └── gitops
                └── podinfo.application.gen.yaml

    6 directories, 2 files
    ```
  </TabItem>
</Tabs>

Note the new `podinfo.application.gen.yaml` created by enabling the ArgoCD in
the Helm component.  The Application resource in the file looks like the
following.

<Tabs groupId="podinfo-application">
  <TabItem value="file" label="podinfo.application.gen.yaml">
    ```yaml showLineNumbers
    apiVersion: argoproj.io/v1alpha1
    kind: Application
    metadata:
      name: podinfo
      namespace: argocd
    spec:
      destination:
        server: https://kubernetes.default.svc
      project: default
      source:
        path: ./deploy/clusters/default/components/podinfo
        repoURL: https://example.com/holos-quickstart.git
        targetRevision: main
    ```
  </TabItem>
</Tabs>

:::tip

Holos will generate a similar Application resource for all additional Components
added to your Platform.

:::

Finally, add and commit the results to your platform Git repository.

<Tabs groupId="commit-argo">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos render component ./components/podinfo --cluster-name=default"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main f95cef1] holos render component ./components/podinfo --cluster-name=default
     3 files changed, 134 insertions(+)
     create mode 100644 argocd.cue
     create mode 100644 deploy/clusters/default/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/default/gitops/podinfo.application.gen.yaml
    ```
  </TabItem>
</Tabs>

In this section we learned how Holos provides a simple way to mix resources into
Components, like an ArgoCD Application.  Holos provides consistency by managing
an Application resource for every Component added to the platform, all by
defining the configuration in `argocd.cue` at the root of the repository.

## Workload Clusters

We've generated a Component to manage podinfo and integrated it with our
Platform, but rendering the Platform does not render podinfo.  Podinfo isn't
rendered because we haven't assigned any Clusters to the workload Fleet.

Define two new clusters, east and west, and assign them to the workload Fleet.
Create a new file named `clusters.cue` in the root of your git repository with
the following contents:

<Tabs groupId="clusters">
  <TabItem value="clusters.cue" label="clusters.cue">
    ```cue showLineNumbers
    package holos

    // Define two workload clusters for disaster recovery.
    #Fleets: workload: clusters: {
      // In CUE _ indicates values are defined elsewhere.
      east: _
      west: _
    }
    ```
  </TabItem>
</Tabs>

This example demonstrates how Holos simplifies the process of configuring
multiple clusters with similar configuration by grouping them into a Fleet.

:::tip
Fleets are useful to segment a group of Clusters into one leader and multiple
followers by marking one cluster as the primary.  Holos makes the process
of reconfiguring which cluster is the primary safer, easier, and more
consistent.  The primary can be configured to automatically restore persistent
data from backups stored in buckets.  Non-primary clusters can be configured to
automatically follow the primary.

Automatic database backup, restore, and streaming replication is an advanced
topic made possible by Cloud Native PG and CUE.  Check back for a guide on this
topic and additional Day 2 operations topics.
:::

## Render the Platform {#render-platform}

Render the platform to render the podinfo Component for each of the workload
clusters.

<Tabs groupId="render-platform">
  <TabItem value="command" label="Command">
    ```bash
    holos render platform ./platform
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    rendered components/podinfo for cluster west in 99.480792ms
    rendered components/podinfo for cluster east in 99.882667ms
    ```
  </TabItem>
</Tabs>

The render platform command iterates over every Cluster in the Fleet and then
renders each assigned Component.  Note the two additional subdirectories created
under the deploy directory, one for each cluster `east` and `west`.

<Tabs groupId="tree-platform">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        ├── default
        │   ├── components
        │   │   └── podinfo
        │   │       └── podinfo.gen.yaml
        │   └── gitops
        │       └── podinfo.application.gen.yaml
        # highlight-next-line
        ├── east
        │   ├── components
        │   │   └── podinfo
        │   │       └── podinfo.gen.yaml
        │   └── gitops
        │       └── podinfo.application.gen.yaml
        # highlight-next-line
        └── west
            ├── components
            │   └── podinfo
            │       └── podinfo.gen.yaml
            └── gitops
                └── podinfo.application.gen.yaml

    14 directories, 6 files
    ```
  </TabItem>
</Tabs>

Holos provides consistency and safety by ensuring the ArgoCD Application is
defined once, with strong type checking, at the configuration root.

New Application resources are automatically generated for the `east` and `west`
workload Clusters.

<Tabs groupId="applications">
  <TabItem value="east" label="east">
  `deploy/clusters/east/gitops/podinfo.application.gen.yaml`
```yaml showLineNumbers
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/east/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
  <TabItem value="west" label="west">
  `deploy/clusters/west/gitops/podinfo.application.gen.yaml`
```yaml showLineNumbers
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/west/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
  <TabItem value="default" label="default">
  `deploy/clusters/default/gitops/podinfo.application.gen.yaml`
```yaml showLineNumbers
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/default/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
</Tabs>

Add and commit the rendered platform along with the workload Clusters.

<Tabs groupId="commit-render-platform">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos render platform ./platform - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main 5aebcf5] holos render platform ./platform - 0.93.2
     5 files changed, 263 insertions(+)
     create mode 100644 clusters.cue
     create mode 100644 deploy/clusters/east/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/east/gitops/podinfo.application.gen.yaml
     create mode 100644 deploy/clusters/west/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/west/gitops/podinfo.application.gen.yaml
    ```
  </TabItem>
</Tabs>

## Upgrade a Helm Chart

Holos is designed to ease the burden of day 2 operations.  Upgrading software,
integrating new software, and making safe platform-wide configuration changes
are easier to accomplish with Holos.

Let's upgrade the podinfo Component to see how this works in practice.  First,
update the Component version field to the latest upstream Helm chart version.

<Tabs groupId="gen-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos generate component helm podinfo --component-version 6.6.2
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    generated component
    ```
  </TabItem>
</Tabs>

Remove the cached chart version:

<Tabs groupId="gen-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    rm -rf components/podinfo/vendor
    ```
  </TabItem>
</Tabs>

Now re-render the whole Platform:

<Tabs groupId="render-platform2">
  <TabItem value="command" label="Command">
    ```bash
    holos render platform ./platform
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    rendered components/podinfo for cluster east in 327.10475ms
    rendered components/podinfo for cluster west in 327.796541ms
    ```
  </TabItem>
</Tabs>

Note, we're still using the upstream chart without modifying it.  The Holos
component wraps around the chart to mix in the additional resources and
integrate the component with the broader Platform.

## Visualize the Changes

Holos makes it easier to see exactly what changes are made and what resources
will be applied to the API server.  On principle, holos operates against local
files.  The task of applying the files is left to ecosystem tools such as
kubectl and ArgoCD.  This makes it easier for platform operators to inspect
changes before merging them into the main branch, or committing them at all.

For example, using `git diff` we can see the only functional change when
upgrading this helm chart is deploying a new container image tag to each
cluster.  Labels are modified as well, which we can classify as non-functional
changes in this case.  Furthermore, we can slowly roll out this change by
applying it first to the east cluster, then to the west cluster. In this way we
can limit the potential blast radius of a problematic change.

<Tabs groupId="git-diff">
  <TabItem value="command" label="Command">
    ```bash
    git diff deploy/clusters/east
    ```
  </TabItem>
  <TabItem value="output" label="Output">
```diff showLineNumbers
diff --git a/deploy/clusters/east/components/podinfo/podinfo.gen.yaml b/deploy/clusters/east/components/podinfo/podinfo.gen.yaml
index 7cc3332..8c1647d 100644
--- a/deploy/clusters/east/components/podinfo/podinfo.gen.yaml
+++ b/deploy/clusters/east/components/podinfo/podinfo.gen.yaml
@@ -5,9 +5,9 @@ kind: Service
 metadata:
   name: podinfo
   labels:
-    helm.sh/chart: podinfo-6.6.1
+    helm.sh/chart: podinfo-6.6.2
     app.kubernetes.io/name: podinfo
-    app.kubernetes.io/version: "6.6.1"
+    app.kubernetes.io/version: "6.6.2"
     app.kubernetes.io/managed-by: Helm
 spec:
   type: ClusterIP
@@ -29,9 +29,9 @@ kind: Deployment
 metadata:
   name: podinfo
   labels:
-    helm.sh/chart: podinfo-6.6.1
+    helm.sh/chart: podinfo-6.6.2
     app.kubernetes.io/name: podinfo
-    app.kubernetes.io/version: "6.6.1"
+    app.kubernetes.io/version: "6.6.2"
     app.kubernetes.io/managed-by: Helm
 spec:
   replicas: 1
@@ -53,7 +53,7 @@ spec:
       terminationGracePeriodSeconds: 30
       containers:
         - name: podinfo
         # highlight-next-line
-          image: "ghcr.io/stefanprodan/podinfo:6.6.1"
         # highlight-next-line
+          image: "ghcr.io/stefanprodan/podinfo:6.6.2"
           imagePullPolicy: IfNotPresent
           command:
             - ./podinfo
```
  </TabItem>
</Tabs>

:::tip

Holos is designed to surface the _fully rendered_ manifests intended for the
Kubernetes API server to make it easier to see and reason about platform wide
configuration changes.

:::

## Recap {#recap}

In this quickstart guide we learned how Holos makes it easier, safer, and more
consistent to manage a Platform composed of multiple clusters and existing Helm
charts.

We learned how to:

1. Generate a Git repository for the Platform config.
2. Create a Component that wraps the unmodified upstream podinfo Helm chart.
3. Render an individual component.
4. Define root level configuration that mixes in an ArgoCD Application resource
to every Component in the Platform.
5. Define multiple workload clusters which share a _nearly_ identical
configuration, but which can vary when necessary, for example assigning a leader
and followers.
6. Render the manifests for the entire Platform with the `holos render platform`
command.
7. Upgrade a helm chart to the latest version as an important Day 2 task.
8. Visualize the exact changes which _will be_, but have not yet been applied to
each cluster in the Platform.

## Dive Deeper

If you'd like to dive deeper, please take a look at the [Schema API][schema] and
[Core API][core] reference docs.  The main difference between the schema package
and the core package is that the schema is for users to write refined CUE with,
while the core package what the schema produces for `holos` to execute.  Users
rarely need to interact with the core API if they're on the happy path, but can
easily use the core package as an escape hatch when the happy path doesn't lead
to the desired destination.

[application]: https://argo-cd.readthedocs.io/en/stable/user-guide/application-specification/
[schema]: /docs/api/schema/v1alpha3/
[core]: /docs/api/core/v1alpha3/
