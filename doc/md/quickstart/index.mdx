import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';

# Quickstart Guide

This guide shows you the basics of how Holos.  You'll deploy a Helm chart to
Kubernetes using a Component to see how Holos makes the process safer, easier,
and more consistent.

## What you'll need {#Requirements}

You'll need the following tools installed to complete this guide.

1. [holos](/docs/install) - to build the platform.
2. [helm](https://helm.sh/docs/intro/install/) - to render Holos components that
wrap upstream Helm charts.

Optionally, if you'd like to apply the rendered manifests to a real cluster
you'll need:

1. [k3d](https://k3d.io/#installation) - to provide a Kubernetes API server.
2. [OrbStack](https://docs.orbstack.dev/install) or
[Docker](https://docs.docker.com/get-docker/) - to use k3d.
3. [kubectl](https://kubernetes.io/docs/tasks/tools/) - to interact with
kubernetes.

## Install Holos

Install Holos with the following command or other methods listed on the
[Installation](/docs/install/) page.

```bash
go install github.com/holos-run/holos/cmd/holos@latest
```

## Git repository

Start by initializing an empty Git repository.  Holos is designed to operate
against local files in a Git repository.

<Tabs groupId="init">
  <TabItem value="command" label="Command">
    ```bash
    mkdir holos-quickstart
    cd holos-quickstart
    git init
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    Initialized empty Git repository in /holos-quickstart/.git/
    ```
  </TabItem>
</Tabs>

This guide assumes commands are run from the root directory of this Git
repository unless otherwise stated.

## Generate the Platform {#Generate-Platform}

Generate the Platform code in the repository root.  A Platform refers to all of
the software holistically integrated to provide a software development platform
for your organization.  In this guide the platform will contain a single
Component to demonstrate how the concepts fit together.

```bash
holos generate platform quickstart
```

Commit the generated platform config to the repository.

<Tabs groupId="commit-platform">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos generate platform quickstart - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main (root-commit) 0b17b7f] holos generate platform quickstart
     213 files changed, 72349 insertions(+)
     ...
    ```
  </TabItem>
</Tabs>

## Generate a Component {#generate-component}

The platform you generated is empty.  Generate the CUE code definition for a
Component that wraps the podinfo Helm chart.

<Tabs groupId="gen-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos generate component helm podinfo --component-version 6.6.1
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    generated component
    ```
  </TabItem>
</Tabs>

The `--component-version 6.6.1` flag intentionally installs an older release.
We'll see how Holos helps with software upgrades later in this guide.

The generate component command produces two files.  A leaf
`components/podinfo/podinfo.gen.cue` file, and a root `podinfo.gen.cue` file.
Holos takes advantage of the fact that [order is
irrelevant](https://cuelang.org/docs/tour/basics/order-irrelevance/) in CUE to
register the component with the Platform by adding a file to the root of the Git
repository.  The second file defines the component itself in the leaf component
directory.

<Tabs groupId="podinfo-files">
  <TabItem value="components/podinfo/podinfo.gen.cue" label="Leaf">
    `components/podinfo/podinfo.gen.cue`
    ```cue
    package holos

    // Produce a helm chart build plan.
    (#Helm & Chart).Output

    let Chart = {
      Name:      "podinfo"
      Version:   "6.6.2"
      Namespace: "default"

      Repo: name: "podinfo"
      Repo: url:  "https://stefanprodan.github.io/podinfo"

      Values: {}
    }
    ```
  </TabItem>
  <TabItem value="podinfo.gen.cue" label="Root">
    `podinfo.gen.cue`
    ```cue
    package holos

    // Manage podinfo on workload clusters only
    for Cluster in #Fleets.workload.clusters {
      #Platform: Components: "\(Cluster.name)/podinfo": {
        path:    "components/podinfo"
        cluster: Cluster.name
      }
    }
    ```
  </TabItem>
</Tabs>

In this example we're providing the minimal information about the Helm chart we
want to manage.  The name, version, Kubernetes namespace to deploy into, and the
chart repository location.

This chart deploys cleanly with no values provided, but we include an empty
Values struct to illustrate how Holos improves the consistency and safety of
Helm by taking advantage of the strong type checking in CUE.  Shared values,
such as the organization domain name, can safely be passed to all Components
across all clusters in the Platform by defining them at the root of the
configuration.

Commit the generated component config to the repository.

<Tabs groupId="commit-component">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos generate component helm podinfo - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main cc0e90c] holos generate component helm podinfo
     2 files changed, 24 insertions(+)
     create mode 100644 components/podinfo/podinfo.gen.cue
     create mode 100644 podinfo.gen.cue
    ```
  </TabItem>
</Tabs>

## Render the Component

Individual components can be rendered without needing to be included in a
Platform spec, useful when developing a new component.

<Tabs groupId="render-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos render component ./components/podinfo --cluster-name=default
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    cached
    rendered podinfo
    ```
  </TabItem>
</Tabs>

First, the command caches the helm chart locally to speed up subsequent
renderings.  Then the command executes helm to produce the output which is
written into the deploy directory.

<Tabs groupId="tree-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        └── default
            └── components
                └── podinfo
                    └── podinfo.gen.yaml

    5 directories, 1 file
    ```
  </TabItem>
</Tabs>

The component is deployed to one cluster named default. The same component is
often deployed to multiple clusters, for example east and west for reliability.

:::tip

This example is equivalent to executing `helm template` on the chart and saving
the output to a file.  Holos simplifies this task by making it safer and more
consistent across multiple charts.

:::

## Mix in an ArgoCD Application

So far we've seen how Holos is a convenient wrapper around Helm, but we haven't
yet seen how it makes it easier to consistently and safely manage all of the
software that goes into a platform.  We'll mix in an ArgoCD
[Application][application] resource to manage the podinfo Component with GitOps.
We'll define this configuration in a way that is automatically and consistently
re-used across all Components added to the Platform in the future, including
Components which are not Helm charts.

Create a new file named `argocd.cue` in the root of your git repository with the
following contents:

<Tabs groupId="argocd-config">
  <TabItem value="command" label="argocd.cue">
    ```cue
    package holos

    #ArgoConfig: {
      Enabled: true
      RepoURL: "https://example.com/holos-quickstart.git"
    }
    ```
  </TabItem>
  <TabItem value="note" label="Note">
    If you plan to apply the rendered output to a real cluster, change the RepoURL
    to the url of the git repository you created in this guide.  It is sufficient to
    keep the example URL if you're getting a feel for Holos and inspecting the
    rendered output without applying it to a live cluster.
  </TabItem>
</Tabs>

With this file in place, render the component again.

<Tabs groupId="render-podinfo-argocd">
  <TabItem value="command" label="Command">
    ```bash
    holos render component ./components/podinfo --cluster-name=default
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    wrote deploy file
    rendered gitops/podinfo
    rendered podinfo
    ```
  </TabItem>
</Tabs>

Holos uses the locally cached copy of the chart to render the output to improve
performance and reliability.  Then, the Helm template output is rendered along
with an additional ArgoCD Application resource for GitOps in the
`podinfo.application.gen.yaml` file.

:::tip

By defining the ArgoCD configuration at the root, we again take advantage of the
fact that [order is
irrelevant](https://cuelang.org/docs/tour/basics/order-irrelevance/) in CUE.

:::

Defining the configuration at the root causes all of the leaf Components to take
on the ArgoCD configuration and render an Application resource for the
Component.

<Tabs groupId="tree-podinfo-argocd">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        └── default
            ├── components
            │   └── podinfo
            │       └── podinfo.gen.yaml
            └── gitops
                └── podinfo.application.gen.yaml

    6 directories, 2 files
    ```
  </TabItem>
</Tabs>

Note the new `podinfo.application.gen.yaml` created by enabling the ArgoCD in
the Helm component.  The Application resource in the file looks like the
following.

<Tabs groupId="podinfo-application">
  <TabItem value="file" label="podinfo.application.gen.yaml">
    ```yaml
    apiVersion: argoproj.io/v1alpha1
    kind: Application
    metadata:
      name: podinfo
      namespace: argocd
    spec:
      destination:
        server: https://kubernetes.default.svc
      project: default
      source:
        path: ./deploy/clusters/default/components/podinfo
        repoURL: https://example.com/holos-quickstart.git
        targetRevision: main
    ```
  </TabItem>
</Tabs>

:::tip

Holos will generate a similar Application resource for all additional Components
added to your Platform.

:::

Finally, add and commit the results to your platform Git repository.

<Tabs groupId="commit-argo">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos render component ./components/podinfo --cluster-name=default"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main f95cef1] holos render component ./components/podinfo --cluster-name=default
     3 files changed, 134 insertions(+)
     create mode 100644 argocd.cue
     create mode 100644 deploy/clusters/default/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/default/gitops/podinfo.application.gen.yaml
    ```
  </TabItem>
</Tabs>

In this section we learned how Holos provides a simple way to add an ArgoCD
Application resource for the podinfo Component which wraps a Helm chart.  Holos
provides consistency by managing an Application resource for every Component
added to the platform, all by defining the configuration of ArgoCD in the
`argocd.cue` file in the root of the Git repository.

## Workload Clusters

So far, we've generated a Platform and a registered podinfo Component with the
Platform, but we have not yet defined a workload cluster.  Rendering the
Platform has no effect because the podinfo Component applies only to workload
Clusters.

Create a new file named `clusters.cue` in the root of your git repository with
the following content:

<Tabs groupId="clusters">
  <TabItem value="clusters.cue" label="clusters.cue">
    ```cue
    package holos

    // Define two workload clusters for disaster recovery.
    #Fleets: workload: clusters: {
      east: _
      west: _
    }
    ```
  </TabItem>
</Tabs>

In this file we're defining two Clusters named `east` and `west`.  This example
demonstrates how Holos simplifies the process of configuring multiple clusters
with nearly identical configuration, useful for assigning one cluster among a
set as the primary.  Clusters which are not primary can then be configured to
automatically follow the leader.  The primary can be configured to automatically
restore persistent data from backups stored in buckets.

:::tip

Automatic database backup and restore is an advanced topic made possible by
Cloud Native PG.  Check back for a guide on this topic and additional Day 2
operations topics.

:::

## Render the Platform {#render-platform}

With workload clusters defined render the platform to render the podinfo
Component for each cluster.

<Tabs groupId="render-platform">
  <TabItem value="command" label="Command">
    ```bash
    holos render platform ./platform
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    rendered components/podinfo for cluster west in 99.480792ms
    rendered components/podinfo for cluster east in 99.882667ms
    ```
  </TabItem>
</Tabs>

The render platform command iterates over every Cluster and renders each
Component integrated into the Platform.  Note how two additional sub-trees have
been created under the deploy directory, one for each cluster `east` and `west`.

<Tabs groupId="tree-platform">
  <TabItem value="command" label="Command">
    ```bash
    tree deploy
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    deploy
    └── clusters
        ├── default
        │   ├── components
        │   │   └── podinfo
        │   │       └── podinfo.gen.yaml
        │   └── gitops
        │       └── podinfo.application.gen.yaml
        ├── east
        │   ├── components
        │   │   └── podinfo
        │   │       └── podinfo.gen.yaml
        │   └── gitops
        │       └── podinfo.application.gen.yaml
        └── west
            ├── components
            │   └── podinfo
            │       └── podinfo.gen.yaml
            └── gitops
                └── podinfo.application.gen.yaml

    14 directories, 6 files
    ```
  </TabItem>
</Tabs>

Holos provides consistency and safety to these changes by ensuring the ArgoCD
Application is defined in a manner unified with the configuration we placed at
the root.  Note how the Application resource is generated for each cluster.

<Tabs groupId="applications">
  <TabItem value="east" label="east">
  `deploy/clusters/east/gitops/podinfo.application.gen.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/east/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
  <TabItem value="west" label="west">
  `deploy/clusters/west/gitops/podinfo.application.gen.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/west/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
  <TabItem value="default" label="default">
  `deploy/clusters/default/gitops/podinfo.application.gen.yaml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: podinfo
  namespace: argocd
spec:
  destination:
    server: https://kubernetes.default.svc
  project: default
  source:
    # highlight-next-line
    path: ./deploy/clusters/default/components/podinfo
    repoURL: https://example.com/holos-quickstart.git
    targetRevision: main
```
  </TabItem>
</Tabs>

Add and commit the rendered platform with east and west workload clusters.

<Tabs groupId="commit-render-platform">
  <TabItem value="command" label="Command">
    ```bash
    git add .
    git commit -m "holos render platform ./platform - $(holos --version)"
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    [main 5aebcf5] holos render platform ./platform - 0.93.2
     5 files changed, 263 insertions(+)
     create mode 100644 clusters.cue
     create mode 100644 deploy/clusters/east/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/east/gitops/podinfo.application.gen.yaml
     create mode 100644 deploy/clusters/west/components/podinfo/podinfo.gen.yaml
     create mode 100644 deploy/clusters/west/gitops/podinfo.application.gen.yaml
    ```
  </TabItem>
</Tabs>

## Upgrade a Helm Chart

Holos is designed to ease the burden of day 2 operations: upgrading software,
integrating new software, and making platform-wide configuration changes safely
with confidence.

Let's upgrade our Podinfo component to see how this looks in practice.  First,
update the Component version field to the latest upstream Helm chart version
available at the time of writing.

<Tabs groupId="gen-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    holos generate component helm podinfo --component-version 6.6.2
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    generated component
    ```
  </TabItem>
</Tabs>

Remove the cached chart version:

<Tabs groupId="gen-podinfo">
  <TabItem value="command" label="Command">
    ```bash
    rm -rf components/podinfo/vendor
    ```
  </TabItem>
</Tabs>

Now re-render the whole Platform:

<Tabs groupId="render-platform2">
  <TabItem value="command" label="Command">
    ```bash
    holos render platform ./platform
    ```
  </TabItem>
  <TabItem value="output" label="Output">
    ```txt
    rendered components/podinfo for cluster east in 327.10475ms
    rendered components/podinfo for cluster west in 327.796541ms
    ```
  </TabItem>
</Tabs>

Note, we're still using the upstream chart without modifying it.  The Holos
component wraps around the chart to mix in the additional resources and
integrate the component with the broader Platform.

## Visualize the Changes

Holos makes it easier to see exactly what changes are made and what resources
will be applied to the API server.  On principle, holos operates against local
files.  The task of applying the files is left to ecosystem tools such as
kubectl and ArgoCD.  This makes it easier for platform operators to inspect
changes before merging them into the main branch, or committing them at all.

For example, using `git diff` we can see the only functional change when
upgrading this helm chart is deploying a new container image tag to each
cluster.  Labels are modified as well, which we can classify as non-functional
changes in this case.  Furthermore, we can slowly roll out this change by
applying it first to the east cluster, then to the west cluster. In this way we
can limit the potential blast radius of a problematic change.

<Tabs groupId="git-diff">
  <TabItem value="command" label="Command">
    ```bash
    git diff deploy/clusters/east
    ```
  </TabItem>
  <TabItem value="output" label="Output">
```diff
diff --git a/deploy/clusters/east/components/podinfo/podinfo.gen.yaml b/deploy/clusters/east/components/podinfo/podinfo.gen.yaml
index 7cc3332..8c1647d 100644
--- a/deploy/clusters/east/components/podinfo/podinfo.gen.yaml
+++ b/deploy/clusters/east/components/podinfo/podinfo.gen.yaml
@@ -5,9 +5,9 @@ kind: Service
 metadata:
   name: podinfo
   labels:
-    helm.sh/chart: podinfo-6.6.1
+    helm.sh/chart: podinfo-6.6.2
     app.kubernetes.io/name: podinfo
-    app.kubernetes.io/version: "6.6.1"
+    app.kubernetes.io/version: "6.6.2"
     app.kubernetes.io/managed-by: Helm
 spec:
   type: ClusterIP
@@ -29,9 +29,9 @@ kind: Deployment
 metadata:
   name: podinfo
   labels:
-    helm.sh/chart: podinfo-6.6.1
+    helm.sh/chart: podinfo-6.6.2
     app.kubernetes.io/name: podinfo
-    app.kubernetes.io/version: "6.6.1"
+    app.kubernetes.io/version: "6.6.2"
     app.kubernetes.io/managed-by: Helm
 spec:
   replicas: 1
@@ -53,7 +53,7 @@ spec:
       terminationGracePeriodSeconds: 30
       containers:
         - name: podinfo
         # highlight-next-line
-          image: "ghcr.io/stefanprodan/podinfo:6.6.1"
         # highlight-next-line
+          image: "ghcr.io/stefanprodan/podinfo:6.6.2"
           imagePullPolicy: IfNotPresent
           command:
             - ./podinfo
```
  </TabItem>
</Tabs>

:::tip

Holos is designed to surface the _fully rendered_ manifests intended for the
Kubernetes API server to make it easier to see and reason about platform wide
configuration changes.

:::

## Recap {#recap}

In this quickstart guide we learned how Holos makes it easier, safer, and more
consistent to manage a Platform composed of multiple clusters and existing Helm
charts.

We learned how to:

1. Generate a Git repository for the Platform config.
2. Create a Component that wraps the unmodified upstream podinfo Helm chart.
3. Render an individual component.
4. Define root level configuration that mixes in an ArgoCD Application resource
to every Component in the Platform.
5. Define multiple workload clusters which share a _nearly_ identical
configuration, but which can vary when necessary, for example assigning a leader
and followers.
6. Render the manifests for the entire Platform with the `holos render platform`
command.
7. Upgrade a helm chart to the latest version as an important Day 2 task.
8. Visualize the exact changes which _will be_, but have not yet been applied to
each cluster in the Platform.

## Dive Deeper

If you'd like to dive deeper, please take a look at the [Schema API][schema] and
[Core API][core] reference docs.  The main difference between the schema package
and the core package is that the schema is for users to write refined CUE with,
while the core package what the schema produces for `holos` to execute.  Users
rarely need to interact with the core API if they're on the happy path, but can
easily use the core package as an escape hatch when the happy path doesn't lead
to the desired destination.

[application]: https://argo-cd.readthedocs.io/en/stable/user-guide/application-specification/
[schema]: /docs/api/schema/v1alpha3/
[core]: /docs/api/core/v1alpha3/
